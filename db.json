{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/google023b75226bac2fe9.html","hash":"6698906b40746d56540fbc23b2fcd024c8f75960","modified":1566995091565},{"_id":"source/robots.txt","hash":"86cbff37798fec9f99ed02d22e600cd1604af3c0","modified":1566995091565},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1566996245874},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1566996245874},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1566996245875},{"_id":"themes/maupassant/README.md","hash":"90032cb3a46f741a3d6198de9f83ce384505519e","modified":1566996245875},{"_id":"themes/maupassant/_config.yml","hash":"d67293dac1559afd76219b5a9c7e5a006e1f9346","modified":1566996245875},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1566996245886},{"_id":"source/_posts/DOM事件---扫盲.md","hash":"3581ead23cb8e5bbf9008bc53e866305f1bc3d9f","modified":1566996309096},{"_id":"source/_posts/ES6-Reflect对象.md","hash":"44e525fed4268c04bdeedd370ce3318d69febafd","modified":1566996313591},{"_id":"source/_posts/coding仓库搭博客图床.md","hash":"b66cbd390c1e3a58648ac6ed93a874224addad82","modified":1566995091560},{"_id":"source/_posts/docker部署前端dist文件入门.md","hash":"865ce78fb63a7320b4b512739cf7016a39fcdcfb","modified":1566995295277},{"_id":"source/_posts/javascript的作用域和上下文.md","hash":"253dc36f61fbdd1936c233280b6db1cd2b373758","modified":1566996317921},{"_id":"source/_posts/js之Set和Map结构.md","hash":"33bde4cc1948760033ee5de9a15f947f37c43ed6","modified":1566996336286},{"_id":"source/_posts/js之属性名的遍历.md","hash":"19af12359d3c8e5d7b4db8076674131efd6faf59","modified":1566996331757},{"_id":"source/_posts/js类和原型.md","hash":"4382882a3551a662344ddf677097a82f93930c26","modified":1566996322280},{"_id":"source/_posts/js那些剪不断，理还乱的继承.md","hash":"daaaf1f62dd9a8b1ac87565338125d7a79209138","modified":1566996327382},{"_id":"source/_posts/proxy笔记.md","hash":"db54e9a71244573eecc3ac218e04af5c4c22e9c1","modified":1566996342609},{"_id":"source/_posts/浅谈浏览器复制内容到剪切板.md","hash":"922550c3b246b5dadd5a792e0c945c960d9b21e2","modified":1566996302929},{"_id":"source/_posts/理解事件循环机制-EventLoop.md","hash":"3a7349c960e54f449e3c1f2e700aecda80dd0559","modified":1566996298932},{"_id":"source/about/index.md","hash":"3ff63b3b01c669210ff51579a878c8fb6d4deeca","modified":1566995091564},{"_id":"source/history/index.md","hash":"91d70c5622dc5c688d6caf91e3b81830859dea84","modified":1566995091565},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1566996245863},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1566996245867},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1566996235199},{"_id":"themes/maupassant/.git/index","hash":"424286b9c886cc718b8d8740ec5a9a2e57fc9eae","modified":1566996245896},{"_id":"themes/maupassant/.git/packed-refs","hash":"0650516a87bcb11b3dd4edf6bae34f458843447a","modified":1566996245858},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1566996245876},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1566996245876},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1566996245876},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1566996245876},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1566996245877},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1566996245877},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1566996245877},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1566996245877},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1566996245884},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1566996245885},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1566996245885},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1566996245885},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1566996245885},{"_id":"themes/maupassant/layout/post.pug","hash":"f4d17b1b2a590cc076e80d912591648f9e99aeaf","modified":1566996245886},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1566996245886},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1566996245886},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1566996235200},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1566996235202},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1566996235199},{"_id":"themes/maupassant/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1566996235200},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1566996235202},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1566996235200},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1566996235199},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1566996235203},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1566996235201},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1566996235201},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1566996235203},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1566996235198},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"8a854c6520fc45a50d6017d4435ed435511e382f","modified":1566996245864},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"507fd8d2fde98df6216ed7c8f60ebea7cf77bfb2","modified":1566996245878},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1566996245878},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"31bf35a57634ff8a796c71dd5246eba3a3db10ee","modified":1566996245878},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1566996245879},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1566996245879},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1566996245879},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1566996245880},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1566996245880},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1566996245880},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1566996245881},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1566996245880},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1566996245883},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1566996245883},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1566996245882},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1566996245883},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1566996245884},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1566996245884},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1566996245884},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1566996245887},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1566996245887},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1566996245889},{"_id":"themes/maupassant/source/css/style.scss","hash":"fa5dfd0867f95fe1708e6fda90e41db6364c01d9","modified":1566996245888},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1566996245889},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1566996245890},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1566996245891},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1566996245891},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1566996245891},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1566996245891},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1566996245893},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1566996245893},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1566996245892},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1566996245892},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1566996245893},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1566996245894},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1566996245895},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1566996245896},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1566996245896},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1566996245896},{"_id":"themes/maupassant/.git/objects/pack/pack-a48ca4edede81caaa096508a454c25b18f1847a7.idx","hash":"48c3f1298d48f8ede6d7b6010bc0fc4fba91c77a","modified":1566996245849},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"4038440af2ee0106fac646477c3d97866ea52a2f","modified":1566996245864},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1566996245895},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"8a854c6520fc45a50d6017d4435ed435511e382f","modified":1566996245865},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1566996245863},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"8a854c6520fc45a50d6017d4435ed435511e382f","modified":1566996245863},{"_id":"themes/maupassant/.git/objects/pack/pack-a48ca4edede81caaa096508a454c25b18f1847a7.pack","hash":"b3234452859080d557aa7d8421d7cb1a7d3df739","modified":1566996245847},{"_id":"public/google023b75226bac2fe9.html","hash":"1ad01300efbf12302cdbdd3178ce1ee62968e114","modified":1572270745984},{"_id":"public/sitemap.xml","hash":"0510dd94359909cbab3eb8859447dd167c44256d","modified":1572270745984},{"_id":"public/about/index.html","hash":"a7942a631675ce20776e568344620801f4d269b0","modified":1572270745997},{"_id":"public/history/index.html","hash":"9d3c32c8b5324e7c98e21e1a5173a80692d03f6a","modified":1572270745997},{"_id":"public/2019/02/28/理解事件循环机制-EventLoop/index.html","hash":"14a2c59b52189df3ea251ff4385300e2113203c2","modified":1572270745997},{"_id":"public/2019/02/17/javascript的作用域和上下文/index.html","hash":"3a261bbc1421e533b212f8f7d5a9df5b5f08cc03","modified":1572270745997},{"_id":"public/2019/02/03/js类和原型/index.html","hash":"26aae82612d007dbfd8d07b1eaf2dc79ed818dce","modified":1572270745997},{"_id":"public/2019/01/26/ES6-Reflect对象/index.html","hash":"eb929f9b44d563c77b1d4199df60fbd59c97a62a","modified":1572270745997},{"_id":"public/2019/01/25/proxy笔记/index.html","hash":"2599731969ebb7e40f03592741b8342c958cf78c","modified":1572270745997},{"_id":"public/2019/01/24/js之Set和Map结构/index.html","hash":"35075ea5f9d5d16758062cfe632bc84fb7959c1f","modified":1572270745998},{"_id":"public/2019/01/23/js之属性名的遍历/index.html","hash":"4ef7aa45e43a4542df7acf415d44b5a4e3f5ea98","modified":1572270745998},{"_id":"public/2019/01/22/coding仓库搭博客图床/index.html","hash":"e2621c74116bbf2bf2e81661ee9a660168b9d8a2","modified":1572270745998},{"_id":"public/2018/10/28/浅谈浏览器复制内容到剪切板/index.html","hash":"54e592680b12de7908cb2ecfbc2fc52159c9f374","modified":1572270745998},{"_id":"public/2018/05/03/docker部署前端dist文件入门/index.html","hash":"0de38d6c282574f55fb98e80fb4ac5c14f900270","modified":1572270745998},{"_id":"public/categories/技术/index.html","hash":"d576def8f6c55ff069f27f97e919cd1fe48de483","modified":1572270746000},{"_id":"public/archives/index.html","hash":"08b11e0026412caf5571a242c514051b861d3a41","modified":1572270745998},{"_id":"public/archives/page/2/index.html","hash":"93da33369736f3fdd3b9293f74ab0c61989a9a2e","modified":1572270745998},{"_id":"public/archives/2018/index.html","hash":"dd67affd4475631847b2d7d2666e455a1fdbc98d","modified":1572270745998},{"_id":"public/archives/2018/05/index.html","hash":"dd2d2b4f21d771ce76414edecfe34896085397da","modified":1572270745998},{"_id":"public/archives/2018/10/index.html","hash":"b745288999a2219241245cf5b719a2224c95d530","modified":1572270745998},{"_id":"public/archives/2019/index.html","hash":"feb8911be54970f19302850fbfebe551ac056ddc","modified":1572270745998},{"_id":"public/archives/2019/01/index.html","hash":"2508d3632f5a0f4adc2115951a8aef6a5d1cf558","modified":1572270745999},{"_id":"public/archives/2019/02/index.html","hash":"484b1bea3d45ea11278184645160ebc9595c666f","modified":1572270745999},{"_id":"public/archives/2019/03/index.html","hash":"e0d2b31189abc28d1a273483bd8d0d191a87558e","modified":1572270746000},{"_id":"public/index.html","hash":"2dae73e7648a597fdec7c29581d8afd9d8b37aa8","modified":1572270746000},{"_id":"public/page/2/index.html","hash":"418f1b36220ac2b5b9a966820b5a21c718417546","modified":1572270746000},{"_id":"public/2019/03/04/js那些剪不断，理还乱的继承/index.html","hash":"45c75f13803241d804eeda67c501e02a6403a476","modified":1572270746000},{"_id":"public/2019/02/02/DOM事件---扫盲/index.html","hash":"2b0d9058b3b1e244d3857fb8ee7668a10bdd673b","modified":1572270746000},{"_id":"public/tags/docker/index.html","hash":"922f1a81c1d7330284a432c7a03fc3fbbbedd89f","modified":1572270746000},{"_id":"public/tags/hexo/index.html","hash":"82ca10b6c46a3f99bfac01e0ae83cba481de6e37","modified":1572270746000},{"_id":"public/tags/js/index.html","hash":"ac5c80262c90d904b3debfc4df20630168500414","modified":1572270746000},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1572270746004},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1572270746004},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1572270746005},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1572270746005},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1572270746005},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1572270746005},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1572270746005},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1572270746005},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1572270746005},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1572270746046},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1572270746046},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1572270746046},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1572270746046},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1572270746046},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1572270746046},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1572270746046},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1572270746046},{"_id":"public/donate/index.html","hash":"7374db74b42ed03f138d25f10f8d47e5aab4efec","modified":1572270746046},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1572270746046},{"_id":"public/css/style.css","hash":"50dac51e44b24279f14cd3756bf1b388e5977f74","modified":1572270746046},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1572270746047},{"_id":"public/robots.txt","hash":"86cbff37798fec9f99ed02d22e600cd1604af3c0","modified":1572270746004}],"Category":[{"name":"技术","_id":"ck2a5oy4k000601zzdxzm8fpa"}],"Data":[],"Page":[{"layout":"false","_content":"google-site-verification: google023b75226bac2fe9.html","source":"google023b75226bac2fe9.html","raw":"layout: false\n---\ngoogle-site-verification: google023b75226bac2fe9.html","date":"2019-08-28T12:24:51.565Z","updated":"2019-08-28T12:24:51.565Z","path":"google023b75226bac2fe9.html","title":"","comments":1,"_id":"ck2a5oy3p000001zz1h3onjv0","content":"google-site-verification: google023b75226bac2fe9.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google023b75226bac2fe9.html"},{"title":"about","date":"2018-10-23T07:48:56.000Z","layout":"page","comments":0,"_content":"\n<i id=\"word\" class=\"text\">江湖中人，却没有一身本领行走江湖，只得在这漫漫江湖中寻找我的武林秘籍。</i>\n<style>\n  .text{\n    color: green\n  }\n</style>\n\n<script>\n  let myWord = '江湖中人，却没有一身本领行走江湖，只得在这漫漫江湖中寻找我的武林秘籍。';\n  let i = 1;\n  let html = '';\n  function getMySlice() {\n    if (i > myWord.length) {\n      i = 1;\n    }\n    html = myWord.slice(0,i);\n    i++;\n    document.getElementById('word').innerText = html;\n    setTimeout(getMySlice, 200);\n  }\n  getMySlice();\n</script>","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-10-23 15:48:56\nlayout: page\ncomments: false\n---\n\n<i id=\"word\" class=\"text\">江湖中人，却没有一身本领行走江湖，只得在这漫漫江湖中寻找我的武林秘籍。</i>\n<style>\n  .text{\n    color: green\n  }\n</style>\n\n<script>\n  let myWord = '江湖中人，却没有一身本领行走江湖，只得在这漫漫江湖中寻找我的武林秘籍。';\n  let i = 1;\n  let html = '';\n  function getMySlice() {\n    if (i > myWord.length) {\n      i = 1;\n    }\n    html = myWord.slice(0,i);\n    i++;\n    document.getElementById('word').innerText = html;\n    setTimeout(getMySlice, 200);\n  }\n  getMySlice();\n</script>","updated":"2019-08-28T12:24:51.564Z","path":"about/index.html","_id":"ck2a5oyyh000w01zzuuuyto8k","content":"<p><i id=\"word\" class=\"text\">江湖中人，却没有一身本领行走江湖，只得在这漫漫江湖中寻找我的武林秘籍。</i></p>\n<style>\n  .text{\n    color: green\n  }\n</style>\n\n<script>\n  let myWord = '江湖中人，却没有一身本领行走江湖，只得在这漫漫江湖中寻找我的武林秘籍。';\n  let i = 1;\n  let html = '';\n  function getMySlice() {\n    if (i > myWord.length) {\n      i = 1;\n    }\n    html = myWord.slice(0,i);\n    i++;\n    document.getElementById('word').innerText = html;\n    setTimeout(getMySlice, 200);\n  }\n  getMySlice();\n</script>","site":{"data":{}},"excerpt":"","more":"<p><i id=\"word\" class=\"text\">江湖中人，却没有一身本领行走江湖，只得在这漫漫江湖中寻找我的武林秘籍。</i></p>\n<style>\n  .text{\n    color: green\n  }\n</style>\n\n<script>\n  let myWord = '江湖中人，却没有一身本领行走江湖，只得在这漫漫江湖中寻找我的武林秘籍。';\n  let i = 1;\n  let html = '';\n  function getMySlice() {\n    if (i > myWord.length) {\n      i = 1;\n    }\n    html = myWord.slice(0,i);\n    i++;\n    document.getElementById('word').innerText = html;\n    setTimeout(getMySlice, 200);\n  }\n  getMySlice();\n</script>"},{"title":"时间轴","date":"2018-10-23T08:12:59.000Z","layout":"timeline","comments":0,"_content":"\n","source":"history/index.md","raw":"---\ntitle: 时间轴\ndate: 2018-10-23 16:12:59\nlayout: timeline\ncomments: false\n---\n\n","updated":"2019-08-28T12:24:51.565Z","path":"history/index.html","_id":"ck2a5oyyj000x01zzg61hhiv2","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"DOM事件---扫盲","date":"2019-02-02T03:42:29.000Z","comments":1,"_content":"\n### DOM事件\n事件就是浏览器的一种通知，主要要了解这么些东西：\n\n - 事件类型：键盘（keydown，keyup，keypress），鼠标（mousedown，mousemove，click），触屏（touchstart，touchmove，touchend），表单（submit，click，focus），拖拽，文档加载事件。  \n - 事件对象：触发事件时生成的event对象，包含许多相关属性，如event.target，event.currentTarget，event.keyCode，event.type.\n - 事件流传播：向上冒泡，向下捕获，DOM2级事件的三个阶段。\n - 事件取消：取消事件关联的默认操作，如a标签的重定向\n - 事件注册：三种注册方式，DOM0,DOM2,html属性注册\n - 事件处理程序中的this指向\n\n### 事件流\n我们都知道“向上冒泡，向下捕获”，这其实是2种事件流的传播方式，是因为IE和NetScape两家公司对事件流的不同实现，为什么会出现两种截然相反的事件流实现呢？我见过比较通俗易懂的解释就是“类比同心圆法”，假设一张白纸上有多个同心圆，我们手指放在圆心上，那么我们指向的是多个圆。\n### 事件捕获\n> 当窗口监听到事件发生时，先从离事件源最远的父元素开始通知，比如window最先获得事件通知，然后是document，然后是document.documentElement,接着是body，一级一级往下传播。\n**document.documentElement是获取文档的根元素，如HTML文档的html元素**\n\n### 事件冒泡\n> 事件先从事件源的元素通知，然后逐级向上级父元素通知，与捕获相反，最后通知到window对象。大部分事件都会冒泡，但是也有例外，focus，blur，scroll就不冒泡。\n\n### DOM2级事件\n> 由于事件流机制的不统一，开发过程会带来额外的麻烦。ECMAScript在DOM2中统一了事件流标准，基本是以上两者的结合，事件先从window对象向下捕获，然后到达事件源的元素，再向上冒泡回window对象。\nDOM2事件有3个阶段，按照事件流通知顺序分别是：**捕获阶段--->目标阶段----->冒泡阶段**。\n图片来自：{% link 链接 https://www.w3.org/TR/DOM-Level-3-Events/#event-flow %}\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/event_stream.png 400 400 event-stream %}\n\n### 事件注册\n3种事件注册方式\n\n - **设置HTML属性注册**\n直接在html元素上设置事件处理程序，但是不能包含函数声明，只能是调用函数，或者是代码块。当为代码块形式调用时，this指向当前元素，与event.currentTarget相同。当this是在处理程序的内部开始的指向时，它指向全局对象Window\n```\n<button onclick=\"console.log(this.type)\"></button>  // this指向button元素\n<div onclick=\"myLog()\"></div>\n<script>\nfunction myLog() {\n    console.log(this)  // this指向Window对象\n}\n</script>\n```\n\n - **设置对象属性（DOM0级事件系统）**\n事件处理程序中this指向当前处理事件的元素\n```\nlet btn = document.getElementById(\"btn\");\nbtn.onclick = function(event) {\n    event = event || window.event;  //兼容IE8及以下版本\n    console.log(this)；  //指向id为btn的元素\n}\n```\n\n - **addEventListener(): (DOM2级事件系统)**\n用该函数添加事件处理程序，可以为同一个事件添加多个处理函数，（同一个事件流模式下）他们会按添加顺序分别执行，**注意第3个参数：false（指定事件为冒泡模式，在冒泡到达时生效）;true（指定事件为捕获模式，在捕获到后函数生效）;默认是false。**结合DOM2的事件流机制可以更好理解。\n```\nlet btn = document.getElementById(\"btn\");\nbtn.addEventListener(\"click\", function(event) {\n    console.loh(\"click1\");\n    console.log(this);  // this指向当前处理事件的元素，与event.currentTarget相同\n}, false);\nbtn.addEventListener(\"click\", function(event) {\n    console.log(click2);  // 在上面click1和this输出后打印‘click2’\n})\n```\n\n### 事件取消\n事件取消的方法都是在事件对象event上，有下面三种：\n\n - **preventDefault()：**阻止与事件关联的默认行为，如a标签的重定向与click事件关联。\n - **stopPropagation()：**阻止捕获和冒泡阶段中当前事件的进一步传播。\n - **stopImmediatePropagation()：**不但阻止事件传播，还会阻止在该处理函数后面注册的事件处理函数\n \n\n### 最后\nsf上看到一道事件流相关的题目，把它版过来，方便检验对事件流的理解，如下：\n\n```\n#a{\n    width: 300px;\n    height: 300px;\n    background: pink;\n}\n#b{\n    width: 200px;\n    height: 200px;\n    background: blue;\n}\n#c{\n    width: 100px;\n    height: 100px;\n    background: yellow;\n}\n<div id=\"a\">\n    <div id=\"b\">\n        <div id=\"c\"></div>\n    </div>\n</div>\n```\n\n```\nvar a = document.getElementById(\"a\"),\n    b = document.getElementById(\"b\"),\n    c = document.getElementById(\"c\");\nc.addEventListener(\"click\", function (event) {\n    console.log(\"c1\");\n    // 注意第三个参数没有传进 false , 因为默认传进来的是 false\n    //，代表冒泡阶段调用，个人认为处于目标阶段也会调用的\n});\nc.addEventListener(\"click\", function (event) {\n    console.log(\"c2\");\n}, true);\nb.addEventListener(\"click\", function (event) {\n    console.log(\"b\");\n}, true);\na.addEventListener(\"click\", function (event) {\n    console.log(\"a1\");\n}, true);\na.addEventListener(\"click\", function (event) {\n    console.log(\"a2\")\n});\na.addEventListener(\"click\", function (event) {\n    console.log(\"a3\");\n    event.stopImmediatePropagation();\n}, true);\na.addEventListener(\"click\", function (event) {\n    console.log(\"a4\");\n}, true);\n```\n\n页面结构如下\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/event_stream_test.png 200 200 test %}\n\n问题如下：\n\n - 如果点击c或者b，输出什么?（答案是a1、a3） \n - 如果点击a，输出什么?（答案是 a1、a2、a3）","source":"_posts/DOM事件---扫盲.md","raw":"---\ntitle: DOM事件---扫盲\ndate: 2019-02-02 11:42:29\ntags: js\ncomments: true\n---\n\n### DOM事件\n事件就是浏览器的一种通知，主要要了解这么些东西：\n\n - 事件类型：键盘（keydown，keyup，keypress），鼠标（mousedown，mousemove，click），触屏（touchstart，touchmove，touchend），表单（submit，click，focus），拖拽，文档加载事件。  \n - 事件对象：触发事件时生成的event对象，包含许多相关属性，如event.target，event.currentTarget，event.keyCode，event.type.\n - 事件流传播：向上冒泡，向下捕获，DOM2级事件的三个阶段。\n - 事件取消：取消事件关联的默认操作，如a标签的重定向\n - 事件注册：三种注册方式，DOM0,DOM2,html属性注册\n - 事件处理程序中的this指向\n\n### 事件流\n我们都知道“向上冒泡，向下捕获”，这其实是2种事件流的传播方式，是因为IE和NetScape两家公司对事件流的不同实现，为什么会出现两种截然相反的事件流实现呢？我见过比较通俗易懂的解释就是“类比同心圆法”，假设一张白纸上有多个同心圆，我们手指放在圆心上，那么我们指向的是多个圆。\n### 事件捕获\n> 当窗口监听到事件发生时，先从离事件源最远的父元素开始通知，比如window最先获得事件通知，然后是document，然后是document.documentElement,接着是body，一级一级往下传播。\n**document.documentElement是获取文档的根元素，如HTML文档的html元素**\n\n### 事件冒泡\n> 事件先从事件源的元素通知，然后逐级向上级父元素通知，与捕获相反，最后通知到window对象。大部分事件都会冒泡，但是也有例外，focus，blur，scroll就不冒泡。\n\n### DOM2级事件\n> 由于事件流机制的不统一，开发过程会带来额外的麻烦。ECMAScript在DOM2中统一了事件流标准，基本是以上两者的结合，事件先从window对象向下捕获，然后到达事件源的元素，再向上冒泡回window对象。\nDOM2事件有3个阶段，按照事件流通知顺序分别是：**捕获阶段--->目标阶段----->冒泡阶段**。\n图片来自：{% link 链接 https://www.w3.org/TR/DOM-Level-3-Events/#event-flow %}\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/event_stream.png 400 400 event-stream %}\n\n### 事件注册\n3种事件注册方式\n\n - **设置HTML属性注册**\n直接在html元素上设置事件处理程序，但是不能包含函数声明，只能是调用函数，或者是代码块。当为代码块形式调用时，this指向当前元素，与event.currentTarget相同。当this是在处理程序的内部开始的指向时，它指向全局对象Window\n```\n<button onclick=\"console.log(this.type)\"></button>  // this指向button元素\n<div onclick=\"myLog()\"></div>\n<script>\nfunction myLog() {\n    console.log(this)  // this指向Window对象\n}\n</script>\n```\n\n - **设置对象属性（DOM0级事件系统）**\n事件处理程序中this指向当前处理事件的元素\n```\nlet btn = document.getElementById(\"btn\");\nbtn.onclick = function(event) {\n    event = event || window.event;  //兼容IE8及以下版本\n    console.log(this)；  //指向id为btn的元素\n}\n```\n\n - **addEventListener(): (DOM2级事件系统)**\n用该函数添加事件处理程序，可以为同一个事件添加多个处理函数，（同一个事件流模式下）他们会按添加顺序分别执行，**注意第3个参数：false（指定事件为冒泡模式，在冒泡到达时生效）;true（指定事件为捕获模式，在捕获到后函数生效）;默认是false。**结合DOM2的事件流机制可以更好理解。\n```\nlet btn = document.getElementById(\"btn\");\nbtn.addEventListener(\"click\", function(event) {\n    console.loh(\"click1\");\n    console.log(this);  // this指向当前处理事件的元素，与event.currentTarget相同\n}, false);\nbtn.addEventListener(\"click\", function(event) {\n    console.log(click2);  // 在上面click1和this输出后打印‘click2’\n})\n```\n\n### 事件取消\n事件取消的方法都是在事件对象event上，有下面三种：\n\n - **preventDefault()：**阻止与事件关联的默认行为，如a标签的重定向与click事件关联。\n - **stopPropagation()：**阻止捕获和冒泡阶段中当前事件的进一步传播。\n - **stopImmediatePropagation()：**不但阻止事件传播，还会阻止在该处理函数后面注册的事件处理函数\n \n\n### 最后\nsf上看到一道事件流相关的题目，把它版过来，方便检验对事件流的理解，如下：\n\n```\n#a{\n    width: 300px;\n    height: 300px;\n    background: pink;\n}\n#b{\n    width: 200px;\n    height: 200px;\n    background: blue;\n}\n#c{\n    width: 100px;\n    height: 100px;\n    background: yellow;\n}\n<div id=\"a\">\n    <div id=\"b\">\n        <div id=\"c\"></div>\n    </div>\n</div>\n```\n\n```\nvar a = document.getElementById(\"a\"),\n    b = document.getElementById(\"b\"),\n    c = document.getElementById(\"c\");\nc.addEventListener(\"click\", function (event) {\n    console.log(\"c1\");\n    // 注意第三个参数没有传进 false , 因为默认传进来的是 false\n    //，代表冒泡阶段调用，个人认为处于目标阶段也会调用的\n});\nc.addEventListener(\"click\", function (event) {\n    console.log(\"c2\");\n}, true);\nb.addEventListener(\"click\", function (event) {\n    console.log(\"b\");\n}, true);\na.addEventListener(\"click\", function (event) {\n    console.log(\"a1\");\n}, true);\na.addEventListener(\"click\", function (event) {\n    console.log(\"a2\")\n});\na.addEventListener(\"click\", function (event) {\n    console.log(\"a3\");\n    event.stopImmediatePropagation();\n}, true);\na.addEventListener(\"click\", function (event) {\n    console.log(\"a4\");\n}, true);\n```\n\n页面结构如下\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/event_stream_test.png 200 200 test %}\n\n问题如下：\n\n - 如果点击c或者b，输出什么?（答案是a1、a3） \n - 如果点击a，输出什么?（答案是 a1、a2、a3）","slug":"DOM事件---扫盲","published":1,"updated":"2019-08-28T12:45:09.096Z","layout":"post","photos":[],"link":"","_id":"ck2a5oy48000101zzr4rvvh31","content":"<h3 id=\"DOM事件\"><a href=\"#DOM事件\" class=\"headerlink\" title=\"DOM事件\"></a>DOM事件</h3><p>事件就是浏览器的一种通知，主要要了解这么些东西：</p>\n<ul>\n<li>事件类型：键盘（keydown，keyup，keypress），鼠标（mousedown，mousemove，click），触屏（touchstart，touchmove，touchend），表单（submit，click，focus），拖拽，文档加载事件。  </li>\n<li>事件对象：触发事件时生成的event对象，包含许多相关属性，如event.target，event.currentTarget，event.keyCode，event.type.</li>\n<li>事件流传播：向上冒泡，向下捕获，DOM2级事件的三个阶段。</li>\n<li>事件取消：取消事件关联的默认操作，如a标签的重定向</li>\n<li>事件注册：三种注册方式，DOM0,DOM2,html属性注册</li>\n<li>事件处理程序中的this指向</li>\n</ul>\n<h3 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h3><p>我们都知道“向上冒泡，向下捕获”，这其实是2种事件流的传播方式，是因为IE和NetScape两家公司对事件流的不同实现，为什么会出现两种截然相反的事件流实现呢？我见过比较通俗易懂的解释就是“类比同心圆法”，假设一张白纸上有多个同心圆，我们手指放在圆心上，那么我们指向的是多个圆。</p>\n<h3 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h3><blockquote>\n<p>当窗口监听到事件发生时，先从离事件源最远的父元素开始通知，比如window最先获得事件通知，然后是document，然后是document.documentElement,接着是body，一级一级往下传播。<br><strong>document.documentElement是获取文档的根元素，如HTML文档的html元素</strong></p>\n</blockquote>\n<h3 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h3><blockquote>\n<p>事件先从事件源的元素通知，然后逐级向上级父元素通知，与捕获相反，最后通知到window对象。大部分事件都会冒泡，但是也有例外，focus，blur，scroll就不冒泡。</p>\n</blockquote>\n<h3 id=\"DOM2级事件\"><a href=\"#DOM2级事件\" class=\"headerlink\" title=\"DOM2级事件\"></a>DOM2级事件</h3><blockquote>\n<p>由于事件流机制的不统一，开发过程会带来额外的麻烦。ECMAScript在DOM2中统一了事件流标准，基本是以上两者的结合，事件先从window对象向下捕获，然后到达事件源的元素，再向上冒泡回window对象。<br>DOM2事件有3个阶段，按照事件流通知顺序分别是：<strong>捕获阶段—&gt;目标阶段—–&gt;冒泡阶段</strong>。<br>图片来自：<a href=\"https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\" target=\"_blank\" rel=\"noopener\">链接</a><br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/event_stream.png\" width=\"400\" height=\"400\" title=\"event-stream\"></p>\n</blockquote>\n<h3 id=\"事件注册\"><a href=\"#事件注册\" class=\"headerlink\" title=\"事件注册\"></a>事件注册</h3><p>3种事件注册方式</p>\n<ul>\n<li><p><strong>设置HTML属性注册</strong><br>直接在html元素上设置事件处理程序，但是不能包含函数声明，只能是调用函数，或者是代码块。当为代码块形式调用时，this指向当前元素，与event.currentTarget相同。当this是在处理程序的内部开始的指向时，它指向全局对象Window</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"console.log(this.type)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>  // this指向button元素</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myLog()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myLog</span><span class=\"params\">()</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)  <span class=\"comment\">// this指向Window对象</span></span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>设置对象属性（DOM0级事件系统）</strong><br>事件处理程序中this指向当前处理事件的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    event = event || <span class=\"built_in\">window</span>.event;  <span class=\"comment\">//兼容IE8及以下版本</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)；  <span class=\"comment\">//指向id为btn的元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>addEventListener(): (DOM2级事件系统)</strong><br>用该函数添加事件处理程序，可以为同一个事件添加多个处理函数，（同一个事件流模式下）他们会按添加顺序分别执行，<strong>注意第3个参数：false（指定事件为冒泡模式，在冒泡到达时生效）;true（指定事件为捕获模式，在捕获到后函数生效）;默认是false。</strong>结合DOM2的事件流机制可以更好理解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.loh(<span class=\"string\">\"click1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);  <span class=\"comment\">// this指向当前处理事件的元素，与event.currentTarget相同</span></span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(click2);  <span class=\"comment\">// 在上面click1和this输出后打印‘click2’</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"事件取消\"><a href=\"#事件取消\" class=\"headerlink\" title=\"事件取消\"></a>事件取消</h3><p>事件取消的方法都是在事件对象event上，有下面三种：</p>\n<ul>\n<li><strong>preventDefault()：</strong>阻止与事件关联的默认行为，如a标签的重定向与click事件关联。</li>\n<li><strong>stopPropagation()：</strong>阻止捕获和冒泡阶段中当前事件的进一步传播。</li>\n<li><strong>stopImmediatePropagation()：</strong>不但阻止事件传播，还会阻止在该处理函数后面注册的事件处理函数</li>\n</ul>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>sf上看到一道事件流相关的题目，把它版过来，方便检验对事件流的理解，如下：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#a&#123;</span></span><br><span class=\"line\"><span class=\"symbol\">    width:</span> <span class=\"number\">300</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    height:</span> <span class=\"number\">300</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    background:</span> pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#b&#123;</span></span><br><span class=\"line\"><span class=\"symbol\">    width:</span> <span class=\"number\">200</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    height:</span> <span class=\"number\">200</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    background:</span> blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#c&#123;</span></span><br><span class=\"line\"><span class=\"symbol\">    width:</span> <span class=\"number\">100</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    height:</span> <span class=\"number\">100</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    background:</span> yellow;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"params\">&lt;div id=\"a\"&gt;</span></span><br><span class=\"line\">    <span class=\"params\">&lt;div id=\"b\"&gt;</span></span><br><span class=\"line\">        <span class=\"params\">&lt;div id=\"c\"&gt;</span><span class=\"params\">&lt;/div&gt;</span></span><br><span class=\"line\">    <span class=\"params\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"params\">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"a\"</span>),</span><br><span class=\"line\">    b = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">    c = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">c.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"c1\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 注意第三个参数没有传进 false , 因为默认传进来的是 false</span></span><br><span class=\"line\">    <span class=\"comment\">//，代表冒泡阶段调用，个人认为处于目标阶段也会调用的</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">c.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"c2\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">b.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">a.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a1\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">a.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a2\"</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">a.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a3\"</span>);</span><br><span class=\"line\">    event.stopImmediatePropagation();</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">a.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a4\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>页面结构如下<br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/event_stream_test.png\" width=\"200\" height=\"200\" title=\"test\"></p>\n<p>问题如下：</p>\n<ul>\n<li>如果点击c或者b，输出什么?（答案是a1、a3） </li>\n<li>如果点击a，输出什么?（答案是 a1、a2、a3）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"DOM事件\"><a href=\"#DOM事件\" class=\"headerlink\" title=\"DOM事件\"></a>DOM事件</h3><p>事件就是浏览器的一种通知，主要要了解这么些东西：</p>\n<ul>\n<li>事件类型：键盘（keydown，keyup，keypress），鼠标（mousedown，mousemove，click），触屏（touchstart，touchmove，touchend），表单（submit，click，focus），拖拽，文档加载事件。  </li>\n<li>事件对象：触发事件时生成的event对象，包含许多相关属性，如event.target，event.currentTarget，event.keyCode，event.type.</li>\n<li>事件流传播：向上冒泡，向下捕获，DOM2级事件的三个阶段。</li>\n<li>事件取消：取消事件关联的默认操作，如a标签的重定向</li>\n<li>事件注册：三种注册方式，DOM0,DOM2,html属性注册</li>\n<li>事件处理程序中的this指向</li>\n</ul>\n<h3 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h3><p>我们都知道“向上冒泡，向下捕获”，这其实是2种事件流的传播方式，是因为IE和NetScape两家公司对事件流的不同实现，为什么会出现两种截然相反的事件流实现呢？我见过比较通俗易懂的解释就是“类比同心圆法”，假设一张白纸上有多个同心圆，我们手指放在圆心上，那么我们指向的是多个圆。</p>\n<h3 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h3><blockquote>\n<p>当窗口监听到事件发生时，先从离事件源最远的父元素开始通知，比如window最先获得事件通知，然后是document，然后是document.documentElement,接着是body，一级一级往下传播。<br><strong>document.documentElement是获取文档的根元素，如HTML文档的html元素</strong></p>\n</blockquote>\n<h3 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h3><blockquote>\n<p>事件先从事件源的元素通知，然后逐级向上级父元素通知，与捕获相反，最后通知到window对象。大部分事件都会冒泡，但是也有例外，focus，blur，scroll就不冒泡。</p>\n</blockquote>\n<h3 id=\"DOM2级事件\"><a href=\"#DOM2级事件\" class=\"headerlink\" title=\"DOM2级事件\"></a>DOM2级事件</h3><blockquote>\n<p>由于事件流机制的不统一，开发过程会带来额外的麻烦。ECMAScript在DOM2中统一了事件流标准，基本是以上两者的结合，事件先从window对象向下捕获，然后到达事件源的元素，再向上冒泡回window对象。<br>DOM2事件有3个阶段，按照事件流通知顺序分别是：<strong>捕获阶段—&gt;目标阶段—–&gt;冒泡阶段</strong>。<br>图片来自：<a href=\"https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\" target=\"_blank\" rel=\"noopener\">链接</a><br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/event_stream.png\" width=\"400\" height=\"400\" title=\"event-stream\"></p>\n</blockquote>\n<h3 id=\"事件注册\"><a href=\"#事件注册\" class=\"headerlink\" title=\"事件注册\"></a>事件注册</h3><p>3种事件注册方式</p>\n<ul>\n<li><p><strong>设置HTML属性注册</strong><br>直接在html元素上设置事件处理程序，但是不能包含函数声明，只能是调用函数，或者是代码块。当为代码块形式调用时，this指向当前元素，与event.currentTarget相同。当this是在处理程序的内部开始的指向时，它指向全局对象Window</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"console.log(this.type)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>  // this指向button元素</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myLog()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myLog</span><span class=\"params\">()</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)  <span class=\"comment\">// this指向Window对象</span></span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>设置对象属性（DOM0级事件系统）</strong><br>事件处理程序中this指向当前处理事件的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    event = event || <span class=\"built_in\">window</span>.event;  <span class=\"comment\">//兼容IE8及以下版本</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)；  <span class=\"comment\">//指向id为btn的元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>addEventListener(): (DOM2级事件系统)</strong><br>用该函数添加事件处理程序，可以为同一个事件添加多个处理函数，（同一个事件流模式下）他们会按添加顺序分别执行，<strong>注意第3个参数：false（指定事件为冒泡模式，在冒泡到达时生效）;true（指定事件为捕获模式，在捕获到后函数生效）;默认是false。</strong>结合DOM2的事件流机制可以更好理解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.loh(<span class=\"string\">\"click1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);  <span class=\"comment\">// this指向当前处理事件的元素，与event.currentTarget相同</span></span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(click2);  <span class=\"comment\">// 在上面click1和this输出后打印‘click2’</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"事件取消\"><a href=\"#事件取消\" class=\"headerlink\" title=\"事件取消\"></a>事件取消</h3><p>事件取消的方法都是在事件对象event上，有下面三种：</p>\n<ul>\n<li><strong>preventDefault()：</strong>阻止与事件关联的默认行为，如a标签的重定向与click事件关联。</li>\n<li><strong>stopPropagation()：</strong>阻止捕获和冒泡阶段中当前事件的进一步传播。</li>\n<li><strong>stopImmediatePropagation()：</strong>不但阻止事件传播，还会阻止在该处理函数后面注册的事件处理函数</li>\n</ul>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>sf上看到一道事件流相关的题目，把它版过来，方便检验对事件流的理解，如下：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#a&#123;</span></span><br><span class=\"line\"><span class=\"symbol\">    width:</span> <span class=\"number\">300</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    height:</span> <span class=\"number\">300</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    background:</span> pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#b&#123;</span></span><br><span class=\"line\"><span class=\"symbol\">    width:</span> <span class=\"number\">200</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    height:</span> <span class=\"number\">200</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    background:</span> blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#c&#123;</span></span><br><span class=\"line\"><span class=\"symbol\">    width:</span> <span class=\"number\">100</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    height:</span> <span class=\"number\">100</span>px;</span><br><span class=\"line\"><span class=\"symbol\">    background:</span> yellow;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"params\">&lt;div id=\"a\"&gt;</span></span><br><span class=\"line\">    <span class=\"params\">&lt;div id=\"b\"&gt;</span></span><br><span class=\"line\">        <span class=\"params\">&lt;div id=\"c\"&gt;</span><span class=\"params\">&lt;/div&gt;</span></span><br><span class=\"line\">    <span class=\"params\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"params\">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"a\"</span>),</span><br><span class=\"line\">    b = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">    c = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">c.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"c1\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 注意第三个参数没有传进 false , 因为默认传进来的是 false</span></span><br><span class=\"line\">    <span class=\"comment\">//，代表冒泡阶段调用，个人认为处于目标阶段也会调用的</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">c.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"c2\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">b.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">a.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a1\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">a.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a2\"</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">a.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a3\"</span>);</span><br><span class=\"line\">    event.stopImmediatePropagation();</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">a.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a4\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>页面结构如下<br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/event_stream_test.png\" width=\"200\" height=\"200\" title=\"test\"></p>\n<p>问题如下：</p>\n<ul>\n<li>如果点击c或者b，输出什么?（答案是a1、a3） </li>\n<li>如果点击a，输出什么?（答案是 a1、a2、a3）</li>\n</ul>\n"},{"title":"ES6--Reflect对象","date":"2019-01-26T14:31:00.000Z","_content":"\n### 前言\nReflect对象是ES6提供的一个新的功能型api对象，就是把Object上的一些方法部署到了Reflect上，这些方法主要是语言本身的方法，比如Object.defineProperty(),现在可以通过Reflect.defineProperty()来调用。\nReflect与Object对象相比，主要有这么些区别：\n\n - **Object上相对语言本身的方法，转移到Reflect上**\n - **对与转移到Reflect的方法，修改部分方法返回值，更符合语义，如defineProperty**\n - **将Object操作转为函数，如in，delete操作用Reflect.has(), Reflect.deleteProperty()代替**\n - **与Proxy对象可以拦截的操作一一对应，保证拦截操作中可以执行原生方法**\n如\n```\nlet p = new Proxy({}, {\n    get(target, prop) {\n        console.log('读取拦截')\n        return Reflect.get(target, prop)\n    }\n})\n```\n\n下面说说转移到Reflect的一些方法\n#### Reflect.get(target, prop [,reciver])\n它是和Proxy的拦截方法get对应的，最后一个参数reciver是**绑定get中this的指向**\n```\nlet obj = {\n    one: 1,\n    two: 2,\n    get sum() {\n        return this.one + this.two\n    }\n}\nlet recObj = {\n    one: 3,\n    two: 4\n}\nReflect.get(obj, sum)  // 3\nReflect.get(obj, sum, recObj) // 7\n```\n\n可以改变get，set里的this指向应该是相对原来定义访问器属性（具有存取描述符）的一个较大的提升，根据MDN上说：get，set里的this指向某个被访问和修改属性的对象。也就是当没有传入reciver参数时，this是原来的指向方式。\n#### Reflect.deleteProperty(target, prop)\n次此方法等同于delete target[prop], 但是它作为转移到Reflect上的新方法，返回布尔值。\n#### Reflect.ownKeys(target)\n等价于原来Object.getPropertyNames(obj) + Object.getPropertySymbols(obj)，返回的是对象自身的所有属性，包括不可枚举，Symbol属性.\n#### Reflect.getPrototypeOf(obj)\n用于获取对象的\\__proto__属性，对应Object.getPrototypeOf(obj)\n\n####  \n其他的方法和Object上的基本对应，就不搬砖了。个人感觉还是get，set第三个参数绑定this的方法要多注意，因为涉及到继承的问题，原来存取器里this的绑定是固定的（上面提过），继承加this绑定搞一起就很容易让人头晕，自己指定this绑定就可以很明确了。","source":"_posts/ES6-Reflect对象.md","raw":"---\ntitle: ES6--Reflect对象\ndate: 2019-01-26 22:31:00\ntags: js\n---\n\n### 前言\nReflect对象是ES6提供的一个新的功能型api对象，就是把Object上的一些方法部署到了Reflect上，这些方法主要是语言本身的方法，比如Object.defineProperty(),现在可以通过Reflect.defineProperty()来调用。\nReflect与Object对象相比，主要有这么些区别：\n\n - **Object上相对语言本身的方法，转移到Reflect上**\n - **对与转移到Reflect的方法，修改部分方法返回值，更符合语义，如defineProperty**\n - **将Object操作转为函数，如in，delete操作用Reflect.has(), Reflect.deleteProperty()代替**\n - **与Proxy对象可以拦截的操作一一对应，保证拦截操作中可以执行原生方法**\n如\n```\nlet p = new Proxy({}, {\n    get(target, prop) {\n        console.log('读取拦截')\n        return Reflect.get(target, prop)\n    }\n})\n```\n\n下面说说转移到Reflect的一些方法\n#### Reflect.get(target, prop [,reciver])\n它是和Proxy的拦截方法get对应的，最后一个参数reciver是**绑定get中this的指向**\n```\nlet obj = {\n    one: 1,\n    two: 2,\n    get sum() {\n        return this.one + this.two\n    }\n}\nlet recObj = {\n    one: 3,\n    two: 4\n}\nReflect.get(obj, sum)  // 3\nReflect.get(obj, sum, recObj) // 7\n```\n\n可以改变get，set里的this指向应该是相对原来定义访问器属性（具有存取描述符）的一个较大的提升，根据MDN上说：get，set里的this指向某个被访问和修改属性的对象。也就是当没有传入reciver参数时，this是原来的指向方式。\n#### Reflect.deleteProperty(target, prop)\n次此方法等同于delete target[prop], 但是它作为转移到Reflect上的新方法，返回布尔值。\n#### Reflect.ownKeys(target)\n等价于原来Object.getPropertyNames(obj) + Object.getPropertySymbols(obj)，返回的是对象自身的所有属性，包括不可枚举，Symbol属性.\n#### Reflect.getPrototypeOf(obj)\n用于获取对象的\\__proto__属性，对应Object.getPrototypeOf(obj)\n\n####  \n其他的方法和Object上的基本对应，就不搬砖了。个人感觉还是get，set第三个参数绑定this的方法要多注意，因为涉及到继承的问题，原来存取器里this的绑定是固定的（上面提过），继承加this绑定搞一起就很容易让人头晕，自己指定this绑定就可以很明确了。","slug":"ES6-Reflect对象","published":1,"updated":"2019-08-28T12:45:13.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2a5oy4d000201zzth6rw4hv","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Reflect对象是ES6提供的一个新的功能型api对象，就是把Object上的一些方法部署到了Reflect上，这些方法主要是语言本身的方法，比如Object.defineProperty(),现在可以通过Reflect.defineProperty()来调用。<br>Reflect与Object对象相比，主要有这么些区别：</p>\n<ul>\n<li><strong>Object上相对语言本身的方法，转移到Reflect上</strong></li>\n<li><strong>对与转移到Reflect的方法，修改部分方法返回值，更符合语义，如defineProperty</strong></li>\n<li><strong>将Object操作转为函数，如in，delete操作用Reflect.has(), Reflect.deleteProperty()代替</strong></li>\n<li><strong>与Proxy对象可以拦截的操作一一对应，保证拦截操作中可以执行原生方法</strong><br>如<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    get(target, prop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'读取拦截'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, prop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>下面说说转移到Reflect的一些方法</p>\n<h4 id=\"Reflect-get-target-prop-reciver\"><a href=\"#Reflect-get-target-prop-reciver\" class=\"headerlink\" title=\"Reflect.get(target, prop [,reciver])\"></a>Reflect.get(target, prop [,reciver])</h4><p>它是和Proxy的拦截方法get对应的，最后一个参数reciver是<strong>绑定get中this的指向</strong><br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">one</span>: 1,</span><br><span class=\"line\">    <span class=\"keyword\">two</span>: 2,</span><br><span class=\"line\">    get <span class=\"built_in\">sum</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> this.<span class=\"keyword\">one</span> + this.<span class=\"keyword\">two</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let recObj = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">one</span>: 3,</span><br><span class=\"line\">    <span class=\"keyword\">two</span>: 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Reflect.<span class=\"built_in\">get</span>(obj, <span class=\"keyword\">sum</span>)  <span class=\"comment\">// 3</span></span><br><span class=\"line\">Reflect.<span class=\"built_in\">get</span>(obj, <span class=\"keyword\">sum</span>, recObj) <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure></p>\n<p>可以改变get，set里的this指向应该是相对原来定义访问器属性（具有存取描述符）的一个较大的提升，根据MDN上说：get，set里的this指向某个被访问和修改属性的对象。也就是当没有传入reciver参数时，this是原来的指向方式。</p>\n<h4 id=\"Reflect-deleteProperty-target-prop\"><a href=\"#Reflect-deleteProperty-target-prop\" class=\"headerlink\" title=\"Reflect.deleteProperty(target, prop)\"></a>Reflect.deleteProperty(target, prop)</h4><p>次此方法等同于delete target[prop], 但是它作为转移到Reflect上的新方法，返回布尔值。</p>\n<h4 id=\"Reflect-ownKeys-target\"><a href=\"#Reflect-ownKeys-target\" class=\"headerlink\" title=\"Reflect.ownKeys(target)\"></a>Reflect.ownKeys(target)</h4><p>等价于原来Object.getPropertyNames(obj) + Object.getPropertySymbols(obj)，返回的是对象自身的所有属性，包括不可枚举，Symbol属性.</p>\n<h4 id=\"Reflect-getPrototypeOf-obj\"><a href=\"#Reflect-getPrototypeOf-obj\" class=\"headerlink\" title=\"Reflect.getPrototypeOf(obj)\"></a>Reflect.getPrototypeOf(obj)</h4><p>用于获取对象的__proto__属性，对应Object.getPrototypeOf(obj)</p>\n<h4 id><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h4><p>其他的方法和Object上的基本对应，就不搬砖了。个人感觉还是get，set第三个参数绑定this的方法要多注意，因为涉及到继承的问题，原来存取器里this的绑定是固定的（上面提过），继承加this绑定搞一起就很容易让人头晕，自己指定this绑定就可以很明确了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Reflect对象是ES6提供的一个新的功能型api对象，就是把Object上的一些方法部署到了Reflect上，这些方法主要是语言本身的方法，比如Object.defineProperty(),现在可以通过Reflect.defineProperty()来调用。<br>Reflect与Object对象相比，主要有这么些区别：</p>\n<ul>\n<li><strong>Object上相对语言本身的方法，转移到Reflect上</strong></li>\n<li><strong>对与转移到Reflect的方法，修改部分方法返回值，更符合语义，如defineProperty</strong></li>\n<li><strong>将Object操作转为函数，如in，delete操作用Reflect.has(), Reflect.deleteProperty()代替</strong></li>\n<li><strong>与Proxy对象可以拦截的操作一一对应，保证拦截操作中可以执行原生方法</strong><br>如<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    get(target, prop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'读取拦截'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, prop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>下面说说转移到Reflect的一些方法</p>\n<h4 id=\"Reflect-get-target-prop-reciver\"><a href=\"#Reflect-get-target-prop-reciver\" class=\"headerlink\" title=\"Reflect.get(target, prop [,reciver])\"></a>Reflect.get(target, prop [,reciver])</h4><p>它是和Proxy的拦截方法get对应的，最后一个参数reciver是<strong>绑定get中this的指向</strong><br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">one</span>: 1,</span><br><span class=\"line\">    <span class=\"keyword\">two</span>: 2,</span><br><span class=\"line\">    get <span class=\"built_in\">sum</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> this.<span class=\"keyword\">one</span> + this.<span class=\"keyword\">two</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let recObj = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">one</span>: 3,</span><br><span class=\"line\">    <span class=\"keyword\">two</span>: 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Reflect.<span class=\"built_in\">get</span>(obj, <span class=\"keyword\">sum</span>)  <span class=\"comment\">// 3</span></span><br><span class=\"line\">Reflect.<span class=\"built_in\">get</span>(obj, <span class=\"keyword\">sum</span>, recObj) <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure></p>\n<p>可以改变get，set里的this指向应该是相对原来定义访问器属性（具有存取描述符）的一个较大的提升，根据MDN上说：get，set里的this指向某个被访问和修改属性的对象。也就是当没有传入reciver参数时，this是原来的指向方式。</p>\n<h4 id=\"Reflect-deleteProperty-target-prop\"><a href=\"#Reflect-deleteProperty-target-prop\" class=\"headerlink\" title=\"Reflect.deleteProperty(target, prop)\"></a>Reflect.deleteProperty(target, prop)</h4><p>次此方法等同于delete target[prop], 但是它作为转移到Reflect上的新方法，返回布尔值。</p>\n<h4 id=\"Reflect-ownKeys-target\"><a href=\"#Reflect-ownKeys-target\" class=\"headerlink\" title=\"Reflect.ownKeys(target)\"></a>Reflect.ownKeys(target)</h4><p>等价于原来Object.getPropertyNames(obj) + Object.getPropertySymbols(obj)，返回的是对象自身的所有属性，包括不可枚举，Symbol属性.</p>\n<h4 id=\"Reflect-getPrototypeOf-obj\"><a href=\"#Reflect-getPrototypeOf-obj\" class=\"headerlink\" title=\"Reflect.getPrototypeOf(obj)\"></a>Reflect.getPrototypeOf(obj)</h4><p>用于获取对象的__proto__属性，对应Object.getPrototypeOf(obj)</p>\n<h4 id><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h4><p>其他的方法和Object上的基本对应，就不搬砖了。个人感觉还是get，set第三个参数绑定this的方法要多注意，因为涉及到继承的问题，原来存取器里this的绑定是固定的（上面提过），继承加this绑定搞一起就很容易让人头晕，自己指定this绑定就可以很明确了。</p>\n"},{"title":"docker部署前端dist文件入门","date":"2018-05-03T13:58:19.000Z","_content":"\n### 前言\n之前一直想学习一下怎仫在服务器上部署web项目，因为每次自己写完页面都要找后端部署，而且每次修改一个bug就要让后端在服务器上更新一下，这样多改几次bug就会让前后端都很烦。于是我就跟着教程学了一下docker，了解了一下nginx，下面是制作nginx镜像部署web的一个学习笔记。\n\n### 正文\n* 1.安装docker\n请根据自己的系统自行安装\n* 2.查看是否安装成功\n        docker -version\n* 3.了解docker\n        docker三大支柱：镜像库、镜像、容器。\n        容器是一个独立的运行环境，所以它解决了应用的移植问题，只需制作相应的镜像就可以在任何装有docker的环境下运行。\n        *镜像是一个特殊的文件系统，包含一些配置，依赖，程序库等等资源。镜像原理主要是镜像层，其依赖于一系列底层技术，也就是镜像最低层的base层。\n* 4.本文用到的docker命令\n        docker images//查看镜像\n        docker pull xx镜像//从创库拉取xx镜像\n        docker run -p xxxx:xx -d xx镜像//以后台方式运行xx镜像的容器，-p指定端口映射\n        docker ps//查看在运行的镜像\n        docker rm xx//删除容器\n        docker stop xx//停止容器\n        docker rmi xx//删除镜像\n        docker build -t image-name .//创建镜像，“.”是Dockerfile文件所在目录，可以指定绝对路径\n        docker exec -it bash//进入容器的伪终端，参数请参阅 –help\n        cat、touch、vim这几个Linux终端命令也会用到\n* 5.拉取官方nginx镜像\n        docker search nginx\n        docker pull nginx//如果网速太慢可以到网易的镜像库拉取\n* 6.把自己的dist文件夹传到主机API文件夹下，修改默认nginx配置\n        touch default.conf\n        vim default.conf\n        //从标准nginx的默认配置复制default.conf内容，然后编辑内容如下\n        server {\n          listen       80;  \n          server_name  localhost;\n\n          #charset koi8-r;\n          #access_log  /var/log/nginx/host.access.log  main;\n\n          location / {\n              root   /usr/share/nginx/html/dist;  //主要是修改这里\n              index  index.html index.htm;\n          }\n\n          #error_page  404              /404.html;\n\n          # redirect server error pages to the static page /50x.html\n          #\n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   /usr/share/nginx/html;\n          }\n\n          # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n          #\n          #location ~ \\.php$ {\n          #    proxy_pass   http://127.0.0.1;\n          #}\n\n          # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n          #\n          #location ~ \\.php$ {\n          #    root           html;\n          #    fastcgi_pass   127.0.0.1:9000;\n          #    fastcgi_index  index.php;\n          #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n          #    include        fastcgi_params;\n          #}\n\n          # deny access to .htaccess files, if Apache's document root\n          # concurs with nginx's one\n          #\n          #location ~ /\\.ht {\n          #    deny  all;\n          #}\n        }\n* 7.制作Dockerfile，文件放在和API同一个目录下\n        touch Dockerfile\n        vim Dockerfile\n        //编辑如下\n        FROM nginx\n        MAINTAINER fyy\n        ADD API /usr/share/nginx/html  //把API文件夹下的文件复制到容器的相应文件夹下\n        COPY default.conf /etc/nginx/conf.d/default.conf  //用自己编辑的配置文件替换nginx容器内的默认配置\n* 8.生成自己的nginx镜像,然后运行\n        docker build -t my-nginx .\n        docker run -p 8080:80 -d my-nginx\n到此结束，你可以访问看看是否成功。以上只是自己入门过程的一些理解，不一定是最正确的，只是当作一个笔记让自己以后方便复习。\n\n写nginx配置时只要写server指令块，如果有其他event和http这些指令会报错（主要因为它会第二次加载其他配置） 然后用该配置替换docker里的nginx默认default.conf。\n\n### 补记\ndocker构建可以理解为多个docker commit，Dockerfile里的每条指令都会commit一次，产生一个镜像层，所以执行一些shell命令时尽量用一个RUN指令。\ndocker构建是基于c/s形式的，本地客户端运行命令实际是操作远程服务端的docker引擎\n> docker build [选项] <上下文路径/URL/->\n\n注意上下文路径的理解，构建过程中我们经常会用到本地的一些文件资源，然而构建实在远程服务端，所以构建时客户端会把指定上下文的路径下所有的文件上传到服务端，当运行COPY指令时指定的**源文件路径**实际是**相对上下文路径**的，**目标文件路径**则是**绝对路径或者相对（WORKDIR）的路径**！","source":"_posts/docker部署前端dist文件入门.md","raw":"---\ntitle: docker部署前端dist文件入门\ndate: 2018-05-03 21:58:19\ntags: docker\ncategory: 技术\n---\n\n### 前言\n之前一直想学习一下怎仫在服务器上部署web项目，因为每次自己写完页面都要找后端部署，而且每次修改一个bug就要让后端在服务器上更新一下，这样多改几次bug就会让前后端都很烦。于是我就跟着教程学了一下docker，了解了一下nginx，下面是制作nginx镜像部署web的一个学习笔记。\n\n### 正文\n* 1.安装docker\n请根据自己的系统自行安装\n* 2.查看是否安装成功\n        docker -version\n* 3.了解docker\n        docker三大支柱：镜像库、镜像、容器。\n        容器是一个独立的运行环境，所以它解决了应用的移植问题，只需制作相应的镜像就可以在任何装有docker的环境下运行。\n        *镜像是一个特殊的文件系统，包含一些配置，依赖，程序库等等资源。镜像原理主要是镜像层，其依赖于一系列底层技术，也就是镜像最低层的base层。\n* 4.本文用到的docker命令\n        docker images//查看镜像\n        docker pull xx镜像//从创库拉取xx镜像\n        docker run -p xxxx:xx -d xx镜像//以后台方式运行xx镜像的容器，-p指定端口映射\n        docker ps//查看在运行的镜像\n        docker rm xx//删除容器\n        docker stop xx//停止容器\n        docker rmi xx//删除镜像\n        docker build -t image-name .//创建镜像，“.”是Dockerfile文件所在目录，可以指定绝对路径\n        docker exec -it bash//进入容器的伪终端，参数请参阅 –help\n        cat、touch、vim这几个Linux终端命令也会用到\n* 5.拉取官方nginx镜像\n        docker search nginx\n        docker pull nginx//如果网速太慢可以到网易的镜像库拉取\n* 6.把自己的dist文件夹传到主机API文件夹下，修改默认nginx配置\n        touch default.conf\n        vim default.conf\n        //从标准nginx的默认配置复制default.conf内容，然后编辑内容如下\n        server {\n          listen       80;  \n          server_name  localhost;\n\n          #charset koi8-r;\n          #access_log  /var/log/nginx/host.access.log  main;\n\n          location / {\n              root   /usr/share/nginx/html/dist;  //主要是修改这里\n              index  index.html index.htm;\n          }\n\n          #error_page  404              /404.html;\n\n          # redirect server error pages to the static page /50x.html\n          #\n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   /usr/share/nginx/html;\n          }\n\n          # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n          #\n          #location ~ \\.php$ {\n          #    proxy_pass   http://127.0.0.1;\n          #}\n\n          # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n          #\n          #location ~ \\.php$ {\n          #    root           html;\n          #    fastcgi_pass   127.0.0.1:9000;\n          #    fastcgi_index  index.php;\n          #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n          #    include        fastcgi_params;\n          #}\n\n          # deny access to .htaccess files, if Apache's document root\n          # concurs with nginx's one\n          #\n          #location ~ /\\.ht {\n          #    deny  all;\n          #}\n        }\n* 7.制作Dockerfile，文件放在和API同一个目录下\n        touch Dockerfile\n        vim Dockerfile\n        //编辑如下\n        FROM nginx\n        MAINTAINER fyy\n        ADD API /usr/share/nginx/html  //把API文件夹下的文件复制到容器的相应文件夹下\n        COPY default.conf /etc/nginx/conf.d/default.conf  //用自己编辑的配置文件替换nginx容器内的默认配置\n* 8.生成自己的nginx镜像,然后运行\n        docker build -t my-nginx .\n        docker run -p 8080:80 -d my-nginx\n到此结束，你可以访问看看是否成功。以上只是自己入门过程的一些理解，不一定是最正确的，只是当作一个笔记让自己以后方便复习。\n\n写nginx配置时只要写server指令块，如果有其他event和http这些指令会报错（主要因为它会第二次加载其他配置） 然后用该配置替换docker里的nginx默认default.conf。\n\n### 补记\ndocker构建可以理解为多个docker commit，Dockerfile里的每条指令都会commit一次，产生一个镜像层，所以执行一些shell命令时尽量用一个RUN指令。\ndocker构建是基于c/s形式的，本地客户端运行命令实际是操作远程服务端的docker引擎\n> docker build [选项] <上下文路径/URL/->\n\n注意上下文路径的理解，构建过程中我们经常会用到本地的一些文件资源，然而构建实在远程服务端，所以构建时客户端会把指定上下文的路径下所有的文件上传到服务端，当运行COPY指令时指定的**源文件路径**实际是**相对上下文路径**的，**目标文件路径**则是**绝对路径或者相对（WORKDIR）的路径**！","slug":"docker部署前端dist文件入门","published":1,"updated":"2019-08-28T12:28:15.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2a5oy4i000401zzin193rno","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>之前一直想学习一下怎仫在服务器上部署web项目，因为每次自己写完页面都要找后端部署，而且每次修改一个bug就要让后端在服务器上更新一下，这样多改几次bug就会让前后端都很烦。于是我就跟着教程学了一下docker，了解了一下nginx，下面是制作nginx镜像部署web的一个学习笔记。</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><ul>\n<li>1.安装docker<br>请根据自己的系统自行安装</li>\n<li>2.查看是否安装成功<pre><code>docker -version\n</code></pre></li>\n<li>3.了解docker<pre><code>docker三大支柱：镜像库、镜像、容器。\n容器是一个独立的运行环境，所以它解决了应用的移植问题，只需制作相应的镜像就可以在任何装有docker的环境下运行。\n*镜像是一个特殊的文件系统，包含一些配置，依赖，程序库等等资源。镜像原理主要是镜像层，其依赖于一系列底层技术，也就是镜像最低层的base层。\n</code></pre></li>\n<li>4.本文用到的docker命令<pre><code>docker images//查看镜像\ndocker pull xx镜像//从创库拉取xx镜像\ndocker run -p xxxx:xx -d xx镜像//以后台方式运行xx镜像的容器，-p指定端口映射\ndocker ps//查看在运行的镜像\ndocker rm xx//删除容器\ndocker stop xx//停止容器\ndocker rmi xx//删除镜像\ndocker build -t image-name .//创建镜像，“.”是Dockerfile文件所在目录，可以指定绝对路径\ndocker exec -it bash//进入容器的伪终端，参数请参阅 –help\ncat、touch、vim这几个Linux终端命令也会用到\n</code></pre></li>\n<li>5.拉取官方nginx镜像<pre><code>docker search nginx\ndocker pull nginx//如果网速太慢可以到网易的镜像库拉取\n</code></pre></li>\n<li><p>6.把自己的dist文件夹传到主机API文件夹下，修改默认nginx配置</p>\n<pre><code>touch default.conf\nvim default.conf\n//从标准nginx的默认配置复制default.conf内容，然后编辑内容如下\nserver {\n  listen       80;  \n  server_name  localhost;\n\n  #charset koi8-r;\n  #access_log  /var/log/nginx/host.access.log  main;\n\n  location / {\n      root   /usr/share/nginx/html/dist;  //主要是修改这里\n      index  index.html index.htm;\n  }\n\n  #error_page  404              /404.html;\n\n  # redirect server error pages to the static page /50x.html\n  #\n  error_page   500 502 503 504  /50x.html;\n  location = /50x.html {\n      root   /usr/share/nginx/html;\n  }\n\n  # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n  #\n  #location ~ \\.php$ {\n  #    proxy_pass   http://127.0.0.1;\n  #}\n\n  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n  #\n  #location ~ \\.php$ {\n  #    root           html;\n  #    fastcgi_pass   127.0.0.1:9000;\n  #    fastcgi_index  index.php;\n  #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n  #    include        fastcgi_params;\n  #}\n\n  # deny access to .htaccess files, if Apache&apos;s document root\n  # concurs with nginx&apos;s one\n  #\n  #location ~ /\\.ht {\n  #    deny  all;\n  #}\n}\n</code></pre></li>\n<li>7.制作Dockerfile，文件放在和API同一个目录下<pre><code>touch Dockerfile\nvim Dockerfile\n//编辑如下\nFROM nginx\nMAINTAINER fyy\nADD API /usr/share/nginx/html  //把API文件夹下的文件复制到容器的相应文件夹下\nCOPY default.conf /etc/nginx/conf.d/default.conf  //用自己编辑的配置文件替换nginx容器内的默认配置\n</code></pre></li>\n<li>8.生成自己的nginx镜像,然后运行<pre><code>docker build -t my-nginx .\ndocker run -p 8080:80 -d my-nginx\n</code></pre>到此结束，你可以访问看看是否成功。以上只是自己入门过程的一些理解，不一定是最正确的，只是当作一个笔记让自己以后方便复习。</li>\n</ul>\n<p>写nginx配置时只要写server指令块，如果有其他event和http这些指令会报错（主要因为它会第二次加载其他配置） 然后用该配置替换docker里的nginx默认default.conf。</p>\n<h3 id=\"补记\"><a href=\"#补记\" class=\"headerlink\" title=\"补记\"></a>补记</h3><p>docker构建可以理解为多个docker commit，Dockerfile里的每条指令都会commit一次，产生一个镜像层，所以执行一些shell命令时尽量用一个RUN指令。<br>docker构建是基于c/s形式的，本地客户端运行命令实际是操作远程服务端的docker引擎</p>\n<blockquote>\n<p>docker build [选项] &lt;上下文路径/URL/-&gt;</p>\n</blockquote>\n<p>注意上下文路径的理解，构建过程中我们经常会用到本地的一些文件资源，然而构建实在远程服务端，所以构建时客户端会把指定上下文的路径下所有的文件上传到服务端，当运行COPY指令时指定的<strong>源文件路径</strong>实际是<strong>相对上下文路径</strong>的，<strong>目标文件路径</strong>则是<strong>绝对路径或者相对（WORKDIR）的路径</strong>！</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>之前一直想学习一下怎仫在服务器上部署web项目，因为每次自己写完页面都要找后端部署，而且每次修改一个bug就要让后端在服务器上更新一下，这样多改几次bug就会让前后端都很烦。于是我就跟着教程学了一下docker，了解了一下nginx，下面是制作nginx镜像部署web的一个学习笔记。</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><ul>\n<li>1.安装docker<br>请根据自己的系统自行安装</li>\n<li>2.查看是否安装成功<pre><code>docker -version\n</code></pre></li>\n<li>3.了解docker<pre><code>docker三大支柱：镜像库、镜像、容器。\n容器是一个独立的运行环境，所以它解决了应用的移植问题，只需制作相应的镜像就可以在任何装有docker的环境下运行。\n*镜像是一个特殊的文件系统，包含一些配置，依赖，程序库等等资源。镜像原理主要是镜像层，其依赖于一系列底层技术，也就是镜像最低层的base层。\n</code></pre></li>\n<li>4.本文用到的docker命令<pre><code>docker images//查看镜像\ndocker pull xx镜像//从创库拉取xx镜像\ndocker run -p xxxx:xx -d xx镜像//以后台方式运行xx镜像的容器，-p指定端口映射\ndocker ps//查看在运行的镜像\ndocker rm xx//删除容器\ndocker stop xx//停止容器\ndocker rmi xx//删除镜像\ndocker build -t image-name .//创建镜像，“.”是Dockerfile文件所在目录，可以指定绝对路径\ndocker exec -it bash//进入容器的伪终端，参数请参阅 –help\ncat、touch、vim这几个Linux终端命令也会用到\n</code></pre></li>\n<li>5.拉取官方nginx镜像<pre><code>docker search nginx\ndocker pull nginx//如果网速太慢可以到网易的镜像库拉取\n</code></pre></li>\n<li><p>6.把自己的dist文件夹传到主机API文件夹下，修改默认nginx配置</p>\n<pre><code>touch default.conf\nvim default.conf\n//从标准nginx的默认配置复制default.conf内容，然后编辑内容如下\nserver {\n  listen       80;  \n  server_name  localhost;\n\n  #charset koi8-r;\n  #access_log  /var/log/nginx/host.access.log  main;\n\n  location / {\n      root   /usr/share/nginx/html/dist;  //主要是修改这里\n      index  index.html index.htm;\n  }\n\n  #error_page  404              /404.html;\n\n  # redirect server error pages to the static page /50x.html\n  #\n  error_page   500 502 503 504  /50x.html;\n  location = /50x.html {\n      root   /usr/share/nginx/html;\n  }\n\n  # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n  #\n  #location ~ \\.php$ {\n  #    proxy_pass   http://127.0.0.1;\n  #}\n\n  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n  #\n  #location ~ \\.php$ {\n  #    root           html;\n  #    fastcgi_pass   127.0.0.1:9000;\n  #    fastcgi_index  index.php;\n  #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n  #    include        fastcgi_params;\n  #}\n\n  # deny access to .htaccess files, if Apache&apos;s document root\n  # concurs with nginx&apos;s one\n  #\n  #location ~ /\\.ht {\n  #    deny  all;\n  #}\n}\n</code></pre></li>\n<li>7.制作Dockerfile，文件放在和API同一个目录下<pre><code>touch Dockerfile\nvim Dockerfile\n//编辑如下\nFROM nginx\nMAINTAINER fyy\nADD API /usr/share/nginx/html  //把API文件夹下的文件复制到容器的相应文件夹下\nCOPY default.conf /etc/nginx/conf.d/default.conf  //用自己编辑的配置文件替换nginx容器内的默认配置\n</code></pre></li>\n<li>8.生成自己的nginx镜像,然后运行<pre><code>docker build -t my-nginx .\ndocker run -p 8080:80 -d my-nginx\n</code></pre>到此结束，你可以访问看看是否成功。以上只是自己入门过程的一些理解，不一定是最正确的，只是当作一个笔记让自己以后方便复习。</li>\n</ul>\n<p>写nginx配置时只要写server指令块，如果有其他event和http这些指令会报错（主要因为它会第二次加载其他配置） 然后用该配置替换docker里的nginx默认default.conf。</p>\n<h3 id=\"补记\"><a href=\"#补记\" class=\"headerlink\" title=\"补记\"></a>补记</h3><p>docker构建可以理解为多个docker commit，Dockerfile里的每条指令都会commit一次，产生一个镜像层，所以执行一些shell命令时尽量用一个RUN指令。<br>docker构建是基于c/s形式的，本地客户端运行命令实际是操作远程服务端的docker引擎</p>\n<blockquote>\n<p>docker build [选项] &lt;上下文路径/URL/-&gt;</p>\n</blockquote>\n<p>注意上下文路径的理解，构建过程中我们经常会用到本地的一些文件资源，然而构建实在远程服务端，所以构建时客户端会把指定上下文的路径下所有的文件上传到服务端，当运行COPY指令时指定的<strong>源文件路径</strong>实际是<strong>相对上下文路径</strong>的，<strong>目标文件路径</strong>则是<strong>绝对路径或者相对（WORKDIR）的路径</strong>！</p>\n"},{"title":"javascript的作用域和上下文","date":"2019-02-17T15:43:44.000Z","_content":"\n### 前言\n今天在用es6的proxy实现观察者模式时遇到了一个自己感觉模棱两口的问题，仔细一想也就是变量的作用域到底是取决于定义时还是运行时？在自己理解的过程中，于是就有了这篇文章。\n\n### 作用域\n概念上说它是指变量，函数，对象在特定区域下的可访问性。\n概念都是比较抽象的东西，我们从头说起，js代码到浏览器运行要经过2个过程，编译------>运行。这恰恰对应这作用域和上下文2个概念。也就是说javascript的作用域在编译阶段就已经确定了，换句话来讲就是**作用域的范围取决于定义时的区域**。来个例子理解：\n\n```\nfunction foo1() {\n    let name = 'test';\n    foo2();\n}\nfunction foo2() {\n    console.log(name);\n}\n\nfoo1();  // 输出name is not defined\n```\n上面foo2函数寻找name的路径是：**foo2自身的函数作用域----->全局作用域**，2个作用域里都没有name变量，因此输出未定义。因此我们也可以发现寻找作用域链时的规律：**自身局部作用域----->自身定义时的作用域------>定义时的上层作用域------一直向上追溯。**\njs是静态编译的，上面的name属性在foo1函数的局部作用域内，只在函数内部可以访问（闭包），即使foo2在foo1内运行，但它定义时在全局作用域，所以无法访问foo1局部作用域，这也就是上面总结的：作用域范围取决于定义时，一个变量的可访问性要看定义时的作用域及作用域链上是否存在该变量。\n","source":"_posts/javascript的作用域和上下文.md","raw":"---\ntitle: javascript的作用域和上下文\ndate: 2019-02-17 23:43:44\ntags: js\n---\n\n### 前言\n今天在用es6的proxy实现观察者模式时遇到了一个自己感觉模棱两口的问题，仔细一想也就是变量的作用域到底是取决于定义时还是运行时？在自己理解的过程中，于是就有了这篇文章。\n\n### 作用域\n概念上说它是指变量，函数，对象在特定区域下的可访问性。\n概念都是比较抽象的东西，我们从头说起，js代码到浏览器运行要经过2个过程，编译------>运行。这恰恰对应这作用域和上下文2个概念。也就是说javascript的作用域在编译阶段就已经确定了，换句话来讲就是**作用域的范围取决于定义时的区域**。来个例子理解：\n\n```\nfunction foo1() {\n    let name = 'test';\n    foo2();\n}\nfunction foo2() {\n    console.log(name);\n}\n\nfoo1();  // 输出name is not defined\n```\n上面foo2函数寻找name的路径是：**foo2自身的函数作用域----->全局作用域**，2个作用域里都没有name变量，因此输出未定义。因此我们也可以发现寻找作用域链时的规律：**自身局部作用域----->自身定义时的作用域------>定义时的上层作用域------一直向上追溯。**\njs是静态编译的，上面的name属性在foo1函数的局部作用域内，只在函数内部可以访问（闭包），即使foo2在foo1内运行，但它定义时在全局作用域，所以无法访问foo1局部作用域，这也就是上面总结的：作用域范围取决于定义时，一个变量的可访问性要看定义时的作用域及作用域链上是否存在该变量。\n","slug":"javascript的作用域和上下文","published":1,"updated":"2019-08-28T12:45:17.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2a5oy4j000501zz7umm8g2j","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>今天在用es6的proxy实现观察者模式时遇到了一个自己感觉模棱两口的问题，仔细一想也就是变量的作用域到底是取决于定义时还是运行时？在自己理解的过程中，于是就有了这篇文章。</p>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>概念上说它是指变量，函数，对象在特定区域下的可访问性。<br>概念都是比较抽象的东西，我们从头说起，js代码到浏览器运行要经过2个过程，编译——&gt;运行。这恰恰对应这作用域和上下文2个概念。也就是说javascript的作用域在编译阶段就已经确定了，换句话来讲就是<strong>作用域的范围取决于定义时的区域</strong>。来个例子理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = <span class=\"string\">'test'</span>;</span><br><span class=\"line\">    foo2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo1();  <span class=\"comment\">// 输出name is not defined</span></span><br></pre></td></tr></table></figure>\n<p>上面foo2函数寻找name的路径是：<strong>foo2自身的函数作用域—–&gt;全局作用域</strong>，2个作用域里都没有name变量，因此输出未定义。因此我们也可以发现寻找作用域链时的规律：<strong>自身局部作用域—–&gt;自身定义时的作用域——&gt;定义时的上层作用域——一直向上追溯。</strong><br>js是静态编译的，上面的name属性在foo1函数的局部作用域内，只在函数内部可以访问（闭包），即使foo2在foo1内运行，但它定义时在全局作用域，所以无法访问foo1局部作用域，这也就是上面总结的：作用域范围取决于定义时，一个变量的可访问性要看定义时的作用域及作用域链上是否存在该变量。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>今天在用es6的proxy实现观察者模式时遇到了一个自己感觉模棱两口的问题，仔细一想也就是变量的作用域到底是取决于定义时还是运行时？在自己理解的过程中，于是就有了这篇文章。</p>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>概念上说它是指变量，函数，对象在特定区域下的可访问性。<br>概念都是比较抽象的东西，我们从头说起，js代码到浏览器运行要经过2个过程，编译——&gt;运行。这恰恰对应这作用域和上下文2个概念。也就是说javascript的作用域在编译阶段就已经确定了，换句话来讲就是<strong>作用域的范围取决于定义时的区域</strong>。来个例子理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = <span class=\"string\">'test'</span>;</span><br><span class=\"line\">    foo2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo1();  <span class=\"comment\">// 输出name is not defined</span></span><br></pre></td></tr></table></figure>\n<p>上面foo2函数寻找name的路径是：<strong>foo2自身的函数作用域—–&gt;全局作用域</strong>，2个作用域里都没有name变量，因此输出未定义。因此我们也可以发现寻找作用域链时的规律：<strong>自身局部作用域—–&gt;自身定义时的作用域——&gt;定义时的上层作用域——一直向上追溯。</strong><br>js是静态编译的，上面的name属性在foo1函数的局部作用域内，只在函数内部可以访问（闭包），即使foo2在foo1内运行，但它定义时在全局作用域，所以无法访问foo1局部作用域，这也就是上面总结的：作用域范围取决于定义时，一个变量的可访问性要看定义时的作用域及作用域链上是否存在该变量。</p>\n"},{"title":"coding仓库搭博客图床","date":"2019-01-22T08:33:43.000Z","comments":1,"_content":"\n### 前言\n用hexo搭好博客时就想过了博客的图片存储问题，但是当时仅仅知识想了一下，并没有实际去解决这个问题（懒癌患者），但是当自己开始认真在博客上记录生活与技术时就不得不搞定这个问题了。\n\n-----\n  博客图床可以有很多方式做，比如：\n  \n - 七牛云存储（要钱要备案）\n - 阿里云静态存储（要钱要备案）\n - 自己服务器上搭个图片服务器，再写个脚本每次部署博客时上传图片并且把链接替换掉\n - github上建个图片仓库？？？，考虑速度问题，可以在coding上建，同样也要写脚本做个转换\n\n我在coding上建了个专门存博客图片的仓库，为了写的时候方便，写博客过程中用相对路径，部署时用脚本替换路径，这样也方便预览。在source目录下建个images文件夹用来存要用到的图片，博客里用`{% img img-url.jpg alt-text %}`相对路径引用图片。写完博客时可以自己先本地预览一下，然后部署时就要自己写个简单的shell脚本来部署，主要是把图片移动到coding图片仓库对应的目录下，然后push上去。在把md文件里的图片链接用脚本替换，然后运行部署命令就可以了。代码大致流程如下：\n\n    #!/bin/bash\n    # $1是coding图床的commit信息\n    # $2是md文件的相对路径 如 source/_posts/fyy.md\n    mv source/images/* /home/fyy/fyy/hexoBlog/blog_images/code_images\n    cd /home/fyy/fyy/hexoBlog/blog_images && git add -A && git commit -m \"$1\" && git push origin master\n    cd /home/fyy/fyy/hexoBlog/myblog && file=$2 node replace-picture-url.js\n    hexo g -d\n上面在部署前运行了个node脚本，用来把链接替换为coding上的链接。一个简单的博客图床就差不多弄好了，但是我感觉还是不够自动化，主要是每次运行这个脚本时还得自己输入要转换的md文件相对路径，有点难受啊，要是能获取到git里已经修改未提交的文件就比较爽了，每次对修改过的md文件做个替换就行。暂时还不知道怎么弄这个，留着以后优化。\n来张图片试试行不行：\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/about.JPG 400 400 测试 %}","source":"_posts/coding仓库搭博客图床.md","raw":"---\ntitle: coding仓库搭博客图床\ndate: 2019-01-22 16:33:43\ntags: hexo\ncomments: true\n---\n\n### 前言\n用hexo搭好博客时就想过了博客的图片存储问题，但是当时仅仅知识想了一下，并没有实际去解决这个问题（懒癌患者），但是当自己开始认真在博客上记录生活与技术时就不得不搞定这个问题了。\n\n-----\n  博客图床可以有很多方式做，比如：\n  \n - 七牛云存储（要钱要备案）\n - 阿里云静态存储（要钱要备案）\n - 自己服务器上搭个图片服务器，再写个脚本每次部署博客时上传图片并且把链接替换掉\n - github上建个图片仓库？？？，考虑速度问题，可以在coding上建，同样也要写脚本做个转换\n\n我在coding上建了个专门存博客图片的仓库，为了写的时候方便，写博客过程中用相对路径，部署时用脚本替换路径，这样也方便预览。在source目录下建个images文件夹用来存要用到的图片，博客里用`{% img img-url.jpg alt-text %}`相对路径引用图片。写完博客时可以自己先本地预览一下，然后部署时就要自己写个简单的shell脚本来部署，主要是把图片移动到coding图片仓库对应的目录下，然后push上去。在把md文件里的图片链接用脚本替换，然后运行部署命令就可以了。代码大致流程如下：\n\n    #!/bin/bash\n    # $1是coding图床的commit信息\n    # $2是md文件的相对路径 如 source/_posts/fyy.md\n    mv source/images/* /home/fyy/fyy/hexoBlog/blog_images/code_images\n    cd /home/fyy/fyy/hexoBlog/blog_images && git add -A && git commit -m \"$1\" && git push origin master\n    cd /home/fyy/fyy/hexoBlog/myblog && file=$2 node replace-picture-url.js\n    hexo g -d\n上面在部署前运行了个node脚本，用来把链接替换为coding上的链接。一个简单的博客图床就差不多弄好了，但是我感觉还是不够自动化，主要是每次运行这个脚本时还得自己输入要转换的md文件相对路径，有点难受啊，要是能获取到git里已经修改未提交的文件就比较爽了，每次对修改过的md文件做个替换就行。暂时还不知道怎么弄这个，留着以后优化。\n来张图片试试行不行：\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/about.JPG 400 400 测试 %}","slug":"coding仓库搭博客图床","published":1,"updated":"2019-08-28T12:24:51.560Z","layout":"post","photos":[],"link":"","_id":"ck2a5oy4l000701zz3nignjw6","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>用hexo搭好博客时就想过了博客的图片存储问题，但是当时仅仅知识想了一下，并没有实际去解决这个问题（懒癌患者），但是当自己开始认真在博客上记录生活与技术时就不得不搞定这个问题了。</p>\n<hr>\n<p>  博客图床可以有很多方式做，比如：</p>\n<ul>\n<li>七牛云存储（要钱要备案）</li>\n<li>阿里云静态存储（要钱要备案）</li>\n<li>自己服务器上搭个图片服务器，再写个脚本每次部署博客时上传图片并且把链接替换掉</li>\n<li>github上建个图片仓库？？？，考虑速度问题，可以在coding上建，同样也要写脚本做个转换</li>\n</ul>\n<p>我在coding上建了个专门存博客图片的仓库，为了写的时候方便，写博客过程中用相对路径，部署时用脚本替换路径，这样也方便预览。在source目录下建个images文件夹用来存要用到的图片，博客里用<code><img class=\"img-url.jpg alt-text\"></code>相对路径引用图片。写完博客时可以自己先本地预览一下，然后部署时就要自己写个简单的shell脚本来部署，主要是把图片移动到coding图片仓库对应的目录下，然后push上去。在把md文件里的图片链接用脚本替换，然后运行部署命令就可以了。代码大致流程如下：</p>\n<pre><code>#!/bin/bash\n# $1是coding图床的commit信息\n# $2是md文件的相对路径 如 source/_posts/fyy.md\nmv source/images/* /home/fyy/fyy/hexoBlog/blog_images/code_images\ncd /home/fyy/fyy/hexoBlog/blog_images &amp;&amp; git add -A &amp;&amp; git commit -m &quot;$1&quot; &amp;&amp; git push origin master\ncd /home/fyy/fyy/hexoBlog/myblog &amp;&amp; file=$2 node replace-picture-url.js\nhexo g -d\n</code></pre><p>上面在部署前运行了个node脚本，用来把链接替换为coding上的链接。一个简单的博客图床就差不多弄好了，但是我感觉还是不够自动化，主要是每次运行这个脚本时还得自己输入要转换的md文件相对路径，有点难受啊，要是能获取到git里已经修改未提交的文件就比较爽了，每次对修改过的md文件做个替换就行。暂时还不知道怎么弄这个，留着以后优化。<br>来张图片试试行不行：<br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/about.JPG\" width=\"400\" height=\"400\" title=\"测试\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>用hexo搭好博客时就想过了博客的图片存储问题，但是当时仅仅知识想了一下，并没有实际去解决这个问题（懒癌患者），但是当自己开始认真在博客上记录生活与技术时就不得不搞定这个问题了。</p>\n<hr>\n<p>  博客图床可以有很多方式做，比如：</p>\n<ul>\n<li>七牛云存储（要钱要备案）</li>\n<li>阿里云静态存储（要钱要备案）</li>\n<li>自己服务器上搭个图片服务器，再写个脚本每次部署博客时上传图片并且把链接替换掉</li>\n<li>github上建个图片仓库？？？，考虑速度问题，可以在coding上建，同样也要写脚本做个转换</li>\n</ul>\n<p>我在coding上建了个专门存博客图片的仓库，为了写的时候方便，写博客过程中用相对路径，部署时用脚本替换路径，这样也方便预览。在source目录下建个images文件夹用来存要用到的图片，博客里用<code><img class=\"img-url.jpg alt-text\"></code>相对路径引用图片。写完博客时可以自己先本地预览一下，然后部署时就要自己写个简单的shell脚本来部署，主要是把图片移动到coding图片仓库对应的目录下，然后push上去。在把md文件里的图片链接用脚本替换，然后运行部署命令就可以了。代码大致流程如下：</p>\n<pre><code>#!/bin/bash\n# $1是coding图床的commit信息\n# $2是md文件的相对路径 如 source/_posts/fyy.md\nmv source/images/* /home/fyy/fyy/hexoBlog/blog_images/code_images\ncd /home/fyy/fyy/hexoBlog/blog_images &amp;&amp; git add -A &amp;&amp; git commit -m &quot;$1&quot; &amp;&amp; git push origin master\ncd /home/fyy/fyy/hexoBlog/myblog &amp;&amp; file=$2 node replace-picture-url.js\nhexo g -d\n</code></pre><p>上面在部署前运行了个node脚本，用来把链接替换为coding上的链接。一个简单的博客图床就差不多弄好了，但是我感觉还是不够自动化，主要是每次运行这个脚本时还得自己输入要转换的md文件相对路径，有点难受啊，要是能获取到git里已经修改未提交的文件就比较爽了，每次对修改过的md文件做个替换就行。暂时还不知道怎么弄这个，留着以后优化。<br>来张图片试试行不行：<br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/about.JPG\" width=\"400\" height=\"400\" title=\"测试\"></p>\n"},{"title":"js之属性名的遍历","date":"2019-01-23T02:42:29.000Z","comments":1,"_content":"\n### 前言\njs里的属性遍历有很多方式，不同遍历方式获取结果也不一样，反正我自己是经常搞混的，每次忘记了就查mdn，过段时间不用然后又忘记了，所以这里汇总一下，做个笔记方便自己回顾\n### 常见的5种属性遍历方式\n> * ***for...in***\n* ***Object.keys(obj)***\n* ***Object.getOwnPropertyNames(obj)***\n* ***Object.getOwnPropertySymbols(obj)***\n* ***Reflect.ownKeys(obj)***\n\n### for...in  \n> 遍历对象**自身**和**继承**的**可枚举属性**（不包括Symbol属性）\n\n### Object.keys(obj)\n> 返回一个数组，遍历对象**自身**的**可枚举属性**（不包含Symbol属性）\n\n### Object.getOwnPropertyNames(obj)\n> 返回一个数组，遍历对象**自身的所有属性**（不包含Symbol属性，但包含了不可枚举属性）\n\n### Object.getOwnPropertySymbols(obj)\n> 返回一个数组，遍历对象**自身的所有Symbol属性**，包括不可枚举属性\n\n### Reflect.ownKeys(obj) \n> 返回一个数组，遍历对象**自身的所有属性**（包含Symbol，可枚举，不可）\n\n根据情况选择遍历方式吧，顺便记录一下，Symbol类型很适合用来实现类似对象的私有属性效果，它并不是私有属性，但是应为Synbol类型的特点，外部难以获取。\n\n每日一图：\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/1-1Q20GF3293Y.JPG 450 400 upday %}\n","source":"_posts/js之属性名的遍历.md","raw":"---\ntitle: js之属性名的遍历\ndate: 2019-01-23 10:42:29\ntags: js\ncomments: true\n---\n\n### 前言\njs里的属性遍历有很多方式，不同遍历方式获取结果也不一样，反正我自己是经常搞混的，每次忘记了就查mdn，过段时间不用然后又忘记了，所以这里汇总一下，做个笔记方便自己回顾\n### 常见的5种属性遍历方式\n> * ***for...in***\n* ***Object.keys(obj)***\n* ***Object.getOwnPropertyNames(obj)***\n* ***Object.getOwnPropertySymbols(obj)***\n* ***Reflect.ownKeys(obj)***\n\n### for...in  \n> 遍历对象**自身**和**继承**的**可枚举属性**（不包括Symbol属性）\n\n### Object.keys(obj)\n> 返回一个数组，遍历对象**自身**的**可枚举属性**（不包含Symbol属性）\n\n### Object.getOwnPropertyNames(obj)\n> 返回一个数组，遍历对象**自身的所有属性**（不包含Symbol属性，但包含了不可枚举属性）\n\n### Object.getOwnPropertySymbols(obj)\n> 返回一个数组，遍历对象**自身的所有Symbol属性**，包括不可枚举属性\n\n### Reflect.ownKeys(obj) \n> 返回一个数组，遍历对象**自身的所有属性**（包含Symbol，可枚举，不可）\n\n根据情况选择遍历方式吧，顺便记录一下，Symbol类型很适合用来实现类似对象的私有属性效果，它并不是私有属性，但是应为Synbol类型的特点，外部难以获取。\n\n每日一图：\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/1-1Q20GF3293Y.JPG 450 400 upday %}\n","slug":"js之属性名的遍历","published":1,"updated":"2019-08-28T12:45:31.757Z","layout":"post","photos":[],"link":"","_id":"ck2a5oy4o000a01zzuoxztqnf","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>js里的属性遍历有很多方式，不同遍历方式获取结果也不一样，反正我自己是经常搞混的，每次忘记了就查mdn，过段时间不用然后又忘记了，所以这里汇总一下，做个笔记方便自己回顾</p>\n<h3 id=\"常见的5种属性遍历方式\"><a href=\"#常见的5种属性遍历方式\" class=\"headerlink\" title=\"常见的5种属性遍历方式\"></a>常见的5种属性遍历方式</h3><blockquote>\n<ul>\n<li><strong><em>for…in</em></strong></li>\n<li><strong><em>Object.keys(obj)</em></strong></li>\n<li><strong><em>Object.getOwnPropertyNames(obj)</em></strong></li>\n<li><strong><em>Object.getOwnPropertySymbols(obj)</em></strong></li>\n<li><strong><em>Reflect.ownKeys(obj)</em></strong></li>\n</ul>\n</blockquote>\n<h3 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h3><blockquote>\n<p>遍历对象<strong>自身</strong>和<strong>继承</strong>的<strong>可枚举属性</strong>（不包括Symbol属性）</p>\n</blockquote>\n<h3 id=\"Object-keys-obj\"><a href=\"#Object-keys-obj\" class=\"headerlink\" title=\"Object.keys(obj)\"></a>Object.keys(obj)</h3><blockquote>\n<p>返回一个数组，遍历对象<strong>自身</strong>的<strong>可枚举属性</strong>（不包含Symbol属性）</p>\n</blockquote>\n<h3 id=\"Object-getOwnPropertyNames-obj\"><a href=\"#Object-getOwnPropertyNames-obj\" class=\"headerlink\" title=\"Object.getOwnPropertyNames(obj)\"></a>Object.getOwnPropertyNames(obj)</h3><blockquote>\n<p>返回一个数组，遍历对象<strong>自身的所有属性</strong>（不包含Symbol属性，但包含了不可枚举属性）</p>\n</blockquote>\n<h3 id=\"Object-getOwnPropertySymbols-obj\"><a href=\"#Object-getOwnPropertySymbols-obj\" class=\"headerlink\" title=\"Object.getOwnPropertySymbols(obj)\"></a>Object.getOwnPropertySymbols(obj)</h3><blockquote>\n<p>返回一个数组，遍历对象<strong>自身的所有Symbol属性</strong>，包括不可枚举属性</p>\n</blockquote>\n<h3 id=\"Reflect-ownKeys-obj\"><a href=\"#Reflect-ownKeys-obj\" class=\"headerlink\" title=\"Reflect.ownKeys(obj)\"></a>Reflect.ownKeys(obj)</h3><blockquote>\n<p>返回一个数组，遍历对象<strong>自身的所有属性</strong>（包含Symbol，可枚举，不可）</p>\n</blockquote>\n<p>根据情况选择遍历方式吧，顺便记录一下，Symbol类型很适合用来实现类似对象的私有属性效果，它并不是私有属性，但是应为Synbol类型的特点，外部难以获取。</p>\n<p>每日一图：<br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/1-1Q20GF3293Y.JPG\" width=\"450\" height=\"400\" title=\"upday\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>js里的属性遍历有很多方式，不同遍历方式获取结果也不一样，反正我自己是经常搞混的，每次忘记了就查mdn，过段时间不用然后又忘记了，所以这里汇总一下，做个笔记方便自己回顾</p>\n<h3 id=\"常见的5种属性遍历方式\"><a href=\"#常见的5种属性遍历方式\" class=\"headerlink\" title=\"常见的5种属性遍历方式\"></a>常见的5种属性遍历方式</h3><blockquote>\n<ul>\n<li><strong><em>for…in</em></strong></li>\n<li><strong><em>Object.keys(obj)</em></strong></li>\n<li><strong><em>Object.getOwnPropertyNames(obj)</em></strong></li>\n<li><strong><em>Object.getOwnPropertySymbols(obj)</em></strong></li>\n<li><strong><em>Reflect.ownKeys(obj)</em></strong></li>\n</ul>\n</blockquote>\n<h3 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h3><blockquote>\n<p>遍历对象<strong>自身</strong>和<strong>继承</strong>的<strong>可枚举属性</strong>（不包括Symbol属性）</p>\n</blockquote>\n<h3 id=\"Object-keys-obj\"><a href=\"#Object-keys-obj\" class=\"headerlink\" title=\"Object.keys(obj)\"></a>Object.keys(obj)</h3><blockquote>\n<p>返回一个数组，遍历对象<strong>自身</strong>的<strong>可枚举属性</strong>（不包含Symbol属性）</p>\n</blockquote>\n<h3 id=\"Object-getOwnPropertyNames-obj\"><a href=\"#Object-getOwnPropertyNames-obj\" class=\"headerlink\" title=\"Object.getOwnPropertyNames(obj)\"></a>Object.getOwnPropertyNames(obj)</h3><blockquote>\n<p>返回一个数组，遍历对象<strong>自身的所有属性</strong>（不包含Symbol属性，但包含了不可枚举属性）</p>\n</blockquote>\n<h3 id=\"Object-getOwnPropertySymbols-obj\"><a href=\"#Object-getOwnPropertySymbols-obj\" class=\"headerlink\" title=\"Object.getOwnPropertySymbols(obj)\"></a>Object.getOwnPropertySymbols(obj)</h3><blockquote>\n<p>返回一个数组，遍历对象<strong>自身的所有Symbol属性</strong>，包括不可枚举属性</p>\n</blockquote>\n<h3 id=\"Reflect-ownKeys-obj\"><a href=\"#Reflect-ownKeys-obj\" class=\"headerlink\" title=\"Reflect.ownKeys(obj)\"></a>Reflect.ownKeys(obj)</h3><blockquote>\n<p>返回一个数组，遍历对象<strong>自身的所有属性</strong>（包含Symbol，可枚举，不可）</p>\n</blockquote>\n<p>根据情况选择遍历方式吧，顺便记录一下，Symbol类型很适合用来实现类似对象的私有属性效果，它并不是私有属性，但是应为Synbol类型的特点，外部难以获取。</p>\n<p>每日一图：<br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/1-1Q20GF3293Y.JPG\" width=\"450\" height=\"400\" title=\"upday\"></p>\n"},{"title":"js类和原型","date":"2019-02-03T15:32:58.000Z","_content":"\n### 前言\n说起面向对象编程，大家应该都知道，也能脱口就道出哪些语言是面向对象的。封装，继承，多态也是随手就可以粘来的词语，我自己也是早就背的滚瓜乱熟了。但是当要把这些概念放到具体语言中理解时，我也不能说出个所以然来。js中的继承就比较特别（和c++,java相比），随着es6+的拓展，js里也有class的概念了。class只是个语法糖，js任然是基于原型的。\n\n### 函数与对象，prototype和\\__proto__\n首先要说的是,\\__proto__是各主流浏览器对对象[[prototype]]属性的实现，现在不建议使用\\__proto__属性，可以用Object.getPrototypeOf(obj)代替。\n> 都说js中一切建皆对象，我个人理解的这句话是：\n> - 基本类型都有对应的包装对象，相互之间可以转化;\n> - 数组是对象的子集，有自身的属性和方法;\n> - 函数是Function构造的实例，也算是对象;\n\n> 但是，函数与对象又不太一样，\n> - 函数可以用new操作符构造新的实例对象，普通对象不能。\n> - 函数有prototype和\\__proto__属性，普通对象没有，它只有\\__proto__属性\n\n#### 补知识来了\n - **如何看待数组是对象？**\n 简单的总结就是数组下标是对象中的key，下标对应的值是value,数组长度是length属性对应的值，并且length只代表数组对象中数值最大的那个键（因为可能存在空值）。\n\n```\nlet a = [];\na.foo = 'foo';\na['hello'] = 'hello';\na['9'] = 55;\nconsole.log(a.length); // 10\n```\n\n - **一切皆对象，那基本类型能像对象一样给属性赋值吗？**\n可以，是的，你没有看错，it`s ok。给基本类型添加属性并赋值，它会转化成对应的包装对象，然后执行复制语句，然后就立马销毁这个包装对象。\n\n```\nlet m = 1;\nm.fn = function () { alert(233) };\nm.fn();\n```\n这段代码会报错，因为调用fn时，m的包装对象已经被销毁了。\n\n<p style=\"text-align: center; font-size: 18px;\">2019.3.1补<p>\n------\n\nprototype属性是为了函数存在的，每一个函数都有自己独一无二的prototype对象,为什么说是独一无二的呢，我自己一开始也是不理解，实例对象的\\__proto__是对构造函数prototype的引用，为了实现继承链，函数原型对象是对谁的引用呢。\n\n```\nfunction Foo() {\n    this.a = 1;\n    this.b = 2;\n}\nlet foo = new Foo();\nfoo.__proto__ == Foo.prototype; // foo是Foo函数构造\nFoo.__proto__ == Function.prototype; // Foo是Function函数构造\nFoo.prototype == ??? // 这是自己一开始疑惑的地方\n```\n\n其实仔细一想，Foo.prototype.constructor只能是Foo函数，所以它是Foo自己独一无二的原型对象，不是其他谁的引用，但是又是怎么实现原型链的呢？既然原型是对象，自然有\\__proto__属性，它是对构造它自己的构造函数的prototype引用。\n\n```\n// 下面两条语句是一个意思\nfoo.__proto__.__proto__ == Object.prototype\nFoo.prototype.__proto__ == Object.prototype\n// 说明Foo函数的原型对象是有Object函数构造\nObject.prototype.__proto__ == null;\n// 说明原型链的终点是null，可以理解为Object函数的原型对象不需要构造了，因为是null\n```\n\n终于摸到点皮毛了，自己最开的疑问其实就是函数的原型对象从何而来，结论：**函数的原型对象（prototype）都是由Object函数构造（在没有人为改变它的原型对象的情况下），对象的原型对象（\\__proto__）指向它的构造函数的原型对象**\n\n看图：\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/prototype_chains.png 原型%}\n\n### 原型链与继承\n原型链就是每个原型对象又有自己的（\\__proto__）原型对象，由\\__proto__不断指向，最终到达null。\n通过原型链实现继承：\n```\nfunction friut(color) {\n    this.color = color;\n}\n\nfunction apple(color, weight) {\n    friut.call(this, color);\n    this.weight = weight;\n}\n apple.prototye = new friut();\n```\n\n还有很多种方法可以实现继承，下次复习new操作符时再整理一下了。","source":"_posts/js类和原型.md","raw":"---\ntitle: js类和原型\ndate: 2019-02-03 23:32:58\ntags: js\n---\n\n### 前言\n说起面向对象编程，大家应该都知道，也能脱口就道出哪些语言是面向对象的。封装，继承，多态也是随手就可以粘来的词语，我自己也是早就背的滚瓜乱熟了。但是当要把这些概念放到具体语言中理解时，我也不能说出个所以然来。js中的继承就比较特别（和c++,java相比），随着es6+的拓展，js里也有class的概念了。class只是个语法糖，js任然是基于原型的。\n\n### 函数与对象，prototype和\\__proto__\n首先要说的是,\\__proto__是各主流浏览器对对象[[prototype]]属性的实现，现在不建议使用\\__proto__属性，可以用Object.getPrototypeOf(obj)代替。\n> 都说js中一切建皆对象，我个人理解的这句话是：\n> - 基本类型都有对应的包装对象，相互之间可以转化;\n> - 数组是对象的子集，有自身的属性和方法;\n> - 函数是Function构造的实例，也算是对象;\n\n> 但是，函数与对象又不太一样，\n> - 函数可以用new操作符构造新的实例对象，普通对象不能。\n> - 函数有prototype和\\__proto__属性，普通对象没有，它只有\\__proto__属性\n\n#### 补知识来了\n - **如何看待数组是对象？**\n 简单的总结就是数组下标是对象中的key，下标对应的值是value,数组长度是length属性对应的值，并且length只代表数组对象中数值最大的那个键（因为可能存在空值）。\n\n```\nlet a = [];\na.foo = 'foo';\na['hello'] = 'hello';\na['9'] = 55;\nconsole.log(a.length); // 10\n```\n\n - **一切皆对象，那基本类型能像对象一样给属性赋值吗？**\n可以，是的，你没有看错，it`s ok。给基本类型添加属性并赋值，它会转化成对应的包装对象，然后执行复制语句，然后就立马销毁这个包装对象。\n\n```\nlet m = 1;\nm.fn = function () { alert(233) };\nm.fn();\n```\n这段代码会报错，因为调用fn时，m的包装对象已经被销毁了。\n\n<p style=\"text-align: center; font-size: 18px;\">2019.3.1补<p>\n------\n\nprototype属性是为了函数存在的，每一个函数都有自己独一无二的prototype对象,为什么说是独一无二的呢，我自己一开始也是不理解，实例对象的\\__proto__是对构造函数prototype的引用，为了实现继承链，函数原型对象是对谁的引用呢。\n\n```\nfunction Foo() {\n    this.a = 1;\n    this.b = 2;\n}\nlet foo = new Foo();\nfoo.__proto__ == Foo.prototype; // foo是Foo函数构造\nFoo.__proto__ == Function.prototype; // Foo是Function函数构造\nFoo.prototype == ??? // 这是自己一开始疑惑的地方\n```\n\n其实仔细一想，Foo.prototype.constructor只能是Foo函数，所以它是Foo自己独一无二的原型对象，不是其他谁的引用，但是又是怎么实现原型链的呢？既然原型是对象，自然有\\__proto__属性，它是对构造它自己的构造函数的prototype引用。\n\n```\n// 下面两条语句是一个意思\nfoo.__proto__.__proto__ == Object.prototype\nFoo.prototype.__proto__ == Object.prototype\n// 说明Foo函数的原型对象是有Object函数构造\nObject.prototype.__proto__ == null;\n// 说明原型链的终点是null，可以理解为Object函数的原型对象不需要构造了，因为是null\n```\n\n终于摸到点皮毛了，自己最开的疑问其实就是函数的原型对象从何而来，结论：**函数的原型对象（prototype）都是由Object函数构造（在没有人为改变它的原型对象的情况下），对象的原型对象（\\__proto__）指向它的构造函数的原型对象**\n\n看图：\n{% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/prototype_chains.png 原型%}\n\n### 原型链与继承\n原型链就是每个原型对象又有自己的（\\__proto__）原型对象，由\\__proto__不断指向，最终到达null。\n通过原型链实现继承：\n```\nfunction friut(color) {\n    this.color = color;\n}\n\nfunction apple(color, weight) {\n    friut.call(this, color);\n    this.weight = weight;\n}\n apple.prototye = new friut();\n```\n\n还有很多种方法可以实现继承，下次复习new操作符时再整理一下了。","slug":"js类和原型","published":1,"updated":"2019-08-28T12:45:22.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2a5oy4p000c01zzyvevm93i","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>说起面向对象编程，大家应该都知道，也能脱口就道出哪些语言是面向对象的。封装，继承，多态也是随手就可以粘来的词语，我自己也是早就背的滚瓜乱熟了。但是当要把这些概念放到具体语言中理解时，我也不能说出个所以然来。js中的继承就比较特别（和c++,java相比），随着es6+的拓展，js里也有class的概念了。class只是个语法糖，js任然是基于原型的。</p>\n<h3 id=\"函数与对象，prototype和-proto\"><a href=\"#函数与对象，prototype和-proto\" class=\"headerlink\" title=\"函数与对象，prototype和__proto__\"></a>函数与对象，prototype和__proto__</h3><p>首先要说的是,__proto__是各主流浏览器对对象[[prototype]]属性的实现，现在不建议使用__proto__属性，可以用Object.getPrototypeOf(obj)代替。</p>\n<blockquote>\n<p>都说js中一切建皆对象，我个人理解的这句话是：</p>\n<ul>\n<li>基本类型都有对应的包装对象，相互之间可以转化;</li>\n<li>数组是对象的子集，有自身的属性和方法;</li>\n<li>函数是Function构造的实例，也算是对象;</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>但是，函数与对象又不太一样，</p>\n<ul>\n<li>函数可以用new操作符构造新的实例对象，普通对象不能。</li>\n<li>函数有prototype和__proto__属性，普通对象没有，它只有__proto__属性</li>\n</ul>\n</blockquote>\n<h4 id=\"补知识来了\"><a href=\"#补知识来了\" class=\"headerlink\" title=\"补知识来了\"></a>补知识来了</h4><ul>\n<li><strong>如何看待数组是对象？</strong><br>简单的总结就是数组下标是对象中的key，下标对应的值是value,数组长度是length属性对应的值，并且length只代表数组对象中数值最大的那个键（因为可能存在空值）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [];</span><br><span class=\"line\">a.foo = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\">a[<span class=\"string\">'hello'</span>] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">a[<span class=\"string\">'9'</span>] = <span class=\"number\">55</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>一切皆对象，那基本类型能像对象一样给属性赋值吗？</strong><br>可以，是的，你没有看错，it`s ok。给基本类型添加属性并赋值，它会转化成对应的包装对象，然后执行复制语句，然后就立马销毁这个包装对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\">m.fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; alert(<span class=\"number\">233</span>) &#125;;</span><br><span class=\"line\">m.fn();</span><br></pre></td></tr></table></figure>\n<p>这段代码会报错，因为调用fn时，m的包装对象已经被销毁了。</p>\n<h2 id=\"2019-3-1补\"><a href=\"#2019-3-1补\" class=\"headerlink\" title=\"2019.3.1补\"></a><p style=\"text-align: center; font-size: 18px;\">2019.3.1补</p><p></p></h2><p>prototype属性是为了函数存在的，每一个函数都有自己独一无二的prototype对象,为什么说是独一无二的呢，我自己一开始也是不理解，实例对象的__proto__是对构造函数prototype的引用，为了实现继承链，函数原型对象是对谁的引用呢。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.__proto__ == Foo.prototype; <span class=\"comment\">// foo是Foo函数构造</span></span><br><span class=\"line\">Foo.__proto__ == <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// Foo是Function函数构造</span></span><br><span class=\"line\">Foo.prototype == ??? <span class=\"comment\">// 这是自己一开始疑惑的地方</span></span><br></pre></td></tr></table></figure>\n<p>其实仔细一想，Foo.prototype.constructor只能是Foo函数，所以它是Foo自己独一无二的原型对象，不是其他谁的引用，但是又是怎么实现原型链的呢？既然原型是对象，自然有__proto__属性，它是对构造它自己的构造函数的prototype引用。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面两条语句是一个意思</span></span><br><span class=\"line\">foo.__proto__.__proto__ == <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\">Foo.prototype.__proto__ == <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"><span class=\"comment\">// 说明Foo函数的原型对象是有Object函数构造</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__ == <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// 说明原型链的终点是null，可以理解为Object函数的原型对象不需要构造了，因为是null</span></span><br></pre></td></tr></table></figure>\n<p>终于摸到点皮毛了，自己最开的疑问其实就是函数的原型对象从何而来，结论：<strong>函数的原型对象（prototype）都是由Object函数构造（在没有人为改变它的原型对象的情况下），对象的原型对象（__proto__）指向它的构造函数的原型对象</strong></p>\n<p>看图：<br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/prototype_chains.png\" title=\"原型\"></p>\n<h3 id=\"原型链与继承\"><a href=\"#原型链与继承\" class=\"headerlink\" title=\"原型链与继承\"></a>原型链与继承</h3><p>原型链就是每个原型对象又有自己的（__proto__）原型对象，由__proto__不断指向，最终到达null。<br>通过原型链实现继承：<br><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">friut</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = <span class=\"built_in\">color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">apple</span>(<span class=\"params\">color, weight</span>) </span>&#123;</span><br><span class=\"line\">    friut.call(<span class=\"keyword\">this</span>, <span class=\"built_in\">color</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> apple.prototye = <span class=\"keyword\">new</span> friut();</span><br></pre></td></tr></table></figure></p>\n<p>还有很多种方法可以实现继承，下次复习new操作符时再整理一下了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>说起面向对象编程，大家应该都知道，也能脱口就道出哪些语言是面向对象的。封装，继承，多态也是随手就可以粘来的词语，我自己也是早就背的滚瓜乱熟了。但是当要把这些概念放到具体语言中理解时，我也不能说出个所以然来。js中的继承就比较特别（和c++,java相比），随着es6+的拓展，js里也有class的概念了。class只是个语法糖，js任然是基于原型的。</p>\n<h3 id=\"函数与对象，prototype和-proto\"><a href=\"#函数与对象，prototype和-proto\" class=\"headerlink\" title=\"函数与对象，prototype和__proto__\"></a>函数与对象，prototype和__proto__</h3><p>首先要说的是,__proto__是各主流浏览器对对象[[prototype]]属性的实现，现在不建议使用__proto__属性，可以用Object.getPrototypeOf(obj)代替。</p>\n<blockquote>\n<p>都说js中一切建皆对象，我个人理解的这句话是：</p>\n<ul>\n<li>基本类型都有对应的包装对象，相互之间可以转化;</li>\n<li>数组是对象的子集，有自身的属性和方法;</li>\n<li>函数是Function构造的实例，也算是对象;</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>但是，函数与对象又不太一样，</p>\n<ul>\n<li>函数可以用new操作符构造新的实例对象，普通对象不能。</li>\n<li>函数有prototype和__proto__属性，普通对象没有，它只有__proto__属性</li>\n</ul>\n</blockquote>\n<h4 id=\"补知识来了\"><a href=\"#补知识来了\" class=\"headerlink\" title=\"补知识来了\"></a>补知识来了</h4><ul>\n<li><strong>如何看待数组是对象？</strong><br>简单的总结就是数组下标是对象中的key，下标对应的值是value,数组长度是length属性对应的值，并且length只代表数组对象中数值最大的那个键（因为可能存在空值）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [];</span><br><span class=\"line\">a.foo = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\">a[<span class=\"string\">'hello'</span>] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">a[<span class=\"string\">'9'</span>] = <span class=\"number\">55</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>一切皆对象，那基本类型能像对象一样给属性赋值吗？</strong><br>可以，是的，你没有看错，it`s ok。给基本类型添加属性并赋值，它会转化成对应的包装对象，然后执行复制语句，然后就立马销毁这个包装对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\">m.fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; alert(<span class=\"number\">233</span>) &#125;;</span><br><span class=\"line\">m.fn();</span><br></pre></td></tr></table></figure>\n<p>这段代码会报错，因为调用fn时，m的包装对象已经被销毁了。</p>\n<h2 id=\"2019-3-1补\"><a href=\"#2019-3-1补\" class=\"headerlink\" title=\"2019.3.1补\"></a><p style=\"text-align: center; font-size: 18px;\">2019.3.1补</p><p></p></h2><p>prototype属性是为了函数存在的，每一个函数都有自己独一无二的prototype对象,为什么说是独一无二的呢，我自己一开始也是不理解，实例对象的__proto__是对构造函数prototype的引用，为了实现继承链，函数原型对象是对谁的引用呢。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.__proto__ == Foo.prototype; <span class=\"comment\">// foo是Foo函数构造</span></span><br><span class=\"line\">Foo.__proto__ == <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// Foo是Function函数构造</span></span><br><span class=\"line\">Foo.prototype == ??? <span class=\"comment\">// 这是自己一开始疑惑的地方</span></span><br></pre></td></tr></table></figure>\n<p>其实仔细一想，Foo.prototype.constructor只能是Foo函数，所以它是Foo自己独一无二的原型对象，不是其他谁的引用，但是又是怎么实现原型链的呢？既然原型是对象，自然有__proto__属性，它是对构造它自己的构造函数的prototype引用。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面两条语句是一个意思</span></span><br><span class=\"line\">foo.__proto__.__proto__ == <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\">Foo.prototype.__proto__ == <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"><span class=\"comment\">// 说明Foo函数的原型对象是有Object函数构造</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__ == <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// 说明原型链的终点是null，可以理解为Object函数的原型对象不需要构造了，因为是null</span></span><br></pre></td></tr></table></figure>\n<p>终于摸到点皮毛了，自己最开的疑问其实就是函数的原型对象从何而来，结论：<strong>函数的原型对象（prototype）都是由Object函数构造（在没有人为改变它的原型对象的情况下），对象的原型对象（__proto__）指向它的构造函数的原型对象</strong></p>\n<p>看图：<br><img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/prototype_chains.png\" title=\"原型\"></p>\n<h3 id=\"原型链与继承\"><a href=\"#原型链与继承\" class=\"headerlink\" title=\"原型链与继承\"></a>原型链与继承</h3><p>原型链就是每个原型对象又有自己的（__proto__）原型对象，由__proto__不断指向，最终到达null。<br>通过原型链实现继承：<br><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">friut</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = <span class=\"built_in\">color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">apple</span>(<span class=\"params\">color, weight</span>) </span>&#123;</span><br><span class=\"line\">    friut.call(<span class=\"keyword\">this</span>, <span class=\"built_in\">color</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> apple.prototye = <span class=\"keyword\">new</span> friut();</span><br></pre></td></tr></table></figure></p>\n<p>还有很多种方法可以实现继承，下次复习new操作符时再整理一下了。</p>\n"},{"title":"js那些剪不断，理还乱的继承","date":"2019-03-04T13:21:16.000Z","_content":"\n### 前言\n曾几何时，自己看过了多少篇的有关js继承的文章，原型链，继承这些挂在一起的概念，本以为自己已经理解了，但是最近再认真梳理时却发现： “原型链和继承， 剪不断，理还乱”。所以这次决定理清楚点。\n\n### 原型链， 继承， new关键字，本是一家人\n为什么把这三个家伙归为一家人呢，因为js里有原型对象，原型对象被串成原型链，js的继承恰好是通过原型链实现的，而new关键字，则是继承的实例化操作者，它根据构造函数创建相应的对象，并且把对象与构造函数的原型（prototype）通过__proto__串起来了。ok，这个实例对象就是继承之后的体现了，它能访问原型链上的各种函数。所以说，原型链，继承，new是一家人，关系剪不断。\n\n### ES5的继承实现方法\n\n - 实例化法\n\n```\nfunction Animal(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nAnimal.prototype.nameReverse = function () {\n  console.log(this.name.split('').reverse().join(''));\n}\n\n/**\n * 实例化原型继承\n */\nfunction Cat0(name, age, tailLength) {\n  Animal.call(this, name, age);\n  this.tailLength = tailLength;\n}\n\nCat0.prototype = new Animal(null, null);\nCat0.prototype.constructor = Cat0; // 不要忘记修正constructor属性\n```\n缺点： 此时Cat0.prototype.\\__proto__ === Animal.prototype,已经达到继承目的，但是在Cat0的prototype对象上产生了多余的父类实例属性\n\n - 直接引用法\n\n```\nfunction Cat1(name, age, tailLength) {\n  Animal.call(this, name, age);\n  this.tailLength = tailLength;\n}\n\nCat1.prototype = Animal.prototype; \nCat1.prototype.constructor = Cat1; // 再次提醒（自己）不要忘记了修正constructor属性\n```\n\n缺点： 子类原型指向父类，它没有自己独立的原型对象，所以当添加属性时会映射到父类，无法形成原型链。\n\n - 构造原型链法\n \n```\nfunction Cat2(name, age, tailLength) {\n  Animal.call(this, name, age);\n  this.tailLength = tailLength;\n}\n\nCat2.prototype = Object.create(Animal.prototype);\nCat2.prototype.constructor = Cat2; // 注意这里并不是修正了，而是添加constructor属性，因为Cat2.prototype是个空对象，只有[[prototypr]]属性(__proto__)\n```\n\n缺点： 这种继承方式比较常见，缺点不怎么明显，本人暂时不知。\n\n - 拷贝继承\n这个没写示例了（因为那啥，拷贝嘛，浅拷贝大家都懂，深拷贝我还得看看书去）\n缺点： 共用方法会在后续的子类的原型中都存有一份拷贝，**很浪费内存**。假设第n代构造函数原型上有n个自己的共用方法，那么它原型上的共用方法有 1+2+3+......+n个。\n\n### ES6的继承\n\n```\n class Person {\n   constructor(name, age) {\n     this.name = name;\n     this.age = age;\n   }\n\n   say() {\n     console.log(`My name is ${this.name} and I am ${this.age} years old`);\n   }\n }\n\n class Student extends Person {\n   constructor(school, ...rest) {\n     super(...rest);\n     this.school = school;\n   }\n\n   getSchool() {\n      console.log(this.school);\n   }\n }\n```\n\n它的原理和构造原型链继承十分相似，不同的是子类的\\__proto__属性会指向父类，ES5的继承是只有一条__proto__链的，它串联了构造函数的原型对象prototype。ES6里通过\\__proto__串联了2条链,如下：\nObject.setPrototypeOf(Student, Person)\nObject.setPrototypeOf(Student.prototype, Person.prototype)。\n\n### ES5继承和ES6的class区别\n\n 1. ES6可以继承内置类型，比如Array, Date, String等，ES5不行。\n 2. ES6有两条链被\\__proto__串起，ES5只有1条。\n\n\n### 总结：我真的理清楚了吗？\n ES5的继承还是理清头绪了的，但是ES6的还有如下疑问：\n \n- ES6可以继承内置类型而ES5不行，如果ES6是语法糖，它都能实现的功能而ES5却不行，为什么？\n- 《ES6标准入门》里说ES6是先构造父类的this对象，父类里的this对象又是指向子类的（很疑惑），而ES5是先构造子函数的this，再通过上下文绑定实现，所以ES6的类语法真的只是封装ES5的继承的语法糖这么简单吗？\n\n这些问题当个记录了，下次自己来补答案。","source":"_posts/js那些剪不断，理还乱的继承.md","raw":"---\ntitle: js那些剪不断，理还乱的继承\ndate: 2019-03-04 21:21:16\ntags: js\n---\n\n### 前言\n曾几何时，自己看过了多少篇的有关js继承的文章，原型链，继承这些挂在一起的概念，本以为自己已经理解了，但是最近再认真梳理时却发现： “原型链和继承， 剪不断，理还乱”。所以这次决定理清楚点。\n\n### 原型链， 继承， new关键字，本是一家人\n为什么把这三个家伙归为一家人呢，因为js里有原型对象，原型对象被串成原型链，js的继承恰好是通过原型链实现的，而new关键字，则是继承的实例化操作者，它根据构造函数创建相应的对象，并且把对象与构造函数的原型（prototype）通过__proto__串起来了。ok，这个实例对象就是继承之后的体现了，它能访问原型链上的各种函数。所以说，原型链，继承，new是一家人，关系剪不断。\n\n### ES5的继承实现方法\n\n - 实例化法\n\n```\nfunction Animal(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nAnimal.prototype.nameReverse = function () {\n  console.log(this.name.split('').reverse().join(''));\n}\n\n/**\n * 实例化原型继承\n */\nfunction Cat0(name, age, tailLength) {\n  Animal.call(this, name, age);\n  this.tailLength = tailLength;\n}\n\nCat0.prototype = new Animal(null, null);\nCat0.prototype.constructor = Cat0; // 不要忘记修正constructor属性\n```\n缺点： 此时Cat0.prototype.\\__proto__ === Animal.prototype,已经达到继承目的，但是在Cat0的prototype对象上产生了多余的父类实例属性\n\n - 直接引用法\n\n```\nfunction Cat1(name, age, tailLength) {\n  Animal.call(this, name, age);\n  this.tailLength = tailLength;\n}\n\nCat1.prototype = Animal.prototype; \nCat1.prototype.constructor = Cat1; // 再次提醒（自己）不要忘记了修正constructor属性\n```\n\n缺点： 子类原型指向父类，它没有自己独立的原型对象，所以当添加属性时会映射到父类，无法形成原型链。\n\n - 构造原型链法\n \n```\nfunction Cat2(name, age, tailLength) {\n  Animal.call(this, name, age);\n  this.tailLength = tailLength;\n}\n\nCat2.prototype = Object.create(Animal.prototype);\nCat2.prototype.constructor = Cat2; // 注意这里并不是修正了，而是添加constructor属性，因为Cat2.prototype是个空对象，只有[[prototypr]]属性(__proto__)\n```\n\n缺点： 这种继承方式比较常见，缺点不怎么明显，本人暂时不知。\n\n - 拷贝继承\n这个没写示例了（因为那啥，拷贝嘛，浅拷贝大家都懂，深拷贝我还得看看书去）\n缺点： 共用方法会在后续的子类的原型中都存有一份拷贝，**很浪费内存**。假设第n代构造函数原型上有n个自己的共用方法，那么它原型上的共用方法有 1+2+3+......+n个。\n\n### ES6的继承\n\n```\n class Person {\n   constructor(name, age) {\n     this.name = name;\n     this.age = age;\n   }\n\n   say() {\n     console.log(`My name is ${this.name} and I am ${this.age} years old`);\n   }\n }\n\n class Student extends Person {\n   constructor(school, ...rest) {\n     super(...rest);\n     this.school = school;\n   }\n\n   getSchool() {\n      console.log(this.school);\n   }\n }\n```\n\n它的原理和构造原型链继承十分相似，不同的是子类的\\__proto__属性会指向父类，ES5的继承是只有一条__proto__链的，它串联了构造函数的原型对象prototype。ES6里通过\\__proto__串联了2条链,如下：\nObject.setPrototypeOf(Student, Person)\nObject.setPrototypeOf(Student.prototype, Person.prototype)。\n\n### ES5继承和ES6的class区别\n\n 1. ES6可以继承内置类型，比如Array, Date, String等，ES5不行。\n 2. ES6有两条链被\\__proto__串起，ES5只有1条。\n\n\n### 总结：我真的理清楚了吗？\n ES5的继承还是理清头绪了的，但是ES6的还有如下疑问：\n \n- ES6可以继承内置类型而ES5不行，如果ES6是语法糖，它都能实现的功能而ES5却不行，为什么？\n- 《ES6标准入门》里说ES6是先构造父类的this对象，父类里的this对象又是指向子类的（很疑惑），而ES5是先构造子函数的this，再通过上下文绑定实现，所以ES6的类语法真的只是封装ES5的继承的语法糖这么简单吗？\n\n这些问题当个记录了，下次自己来补答案。","slug":"js那些剪不断，理还乱的继承","published":1,"updated":"2019-08-28T12:45:27.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2a5oy4q000f01zz4grxu41q","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>曾几何时，自己看过了多少篇的有关js继承的文章，原型链，继承这些挂在一起的概念，本以为自己已经理解了，但是最近再认真梳理时却发现： “原型链和继承， 剪不断，理还乱”。所以这次决定理清楚点。</p>\n<h3 id=\"原型链，-继承，-new关键字，本是一家人\"><a href=\"#原型链，-继承，-new关键字，本是一家人\" class=\"headerlink\" title=\"原型链， 继承， new关键字，本是一家人\"></a>原型链， 继承， new关键字，本是一家人</h3><p>为什么把这三个家伙归为一家人呢，因为js里有原型对象，原型对象被串成原型链，js的继承恰好是通过原型链实现的，而new关键字，则是继承的实例化操作者，它根据构造函数创建相应的对象，并且把对象与构造函数的原型（prototype）通过<strong>proto</strong>串起来了。ok，这个实例对象就是继承之后的体现了，它能访问原型链上的各种函数。所以说，原型链，继承，new是一家人，关系剪不断。</p>\n<h3 id=\"ES5的继承实现方法\"><a href=\"#ES5的继承实现方法\" class=\"headerlink\" title=\"ES5的继承实现方法\"></a>ES5的继承实现方法</h3><ul>\n<li>实例化法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.nameReverse = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实例化原型继承</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat0</span>(<span class=\"params\">name, age, tailLength</span>) </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, name, age);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tailLength = tailLength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat0.prototype = <span class=\"keyword\">new</span> Animal(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">Cat0.prototype.constructor = Cat0; <span class=\"comment\">// 不要忘记修正constructor属性</span></span><br></pre></td></tr></table></figure>\n<p>缺点： 此时Cat0.prototype.__proto__ === Animal.prototype,已经达到继承目的，但是在Cat0的prototype对象上产生了多余的父类实例属性</p>\n<ul>\n<li>直接引用法</li>\n</ul>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat1</span><span class=\"params\">(name, age, tailLength)</span> </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, name, age);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tailLength = tailLength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat1.prototype = Animal.prototype; </span><br><span class=\"line\">Cat1.prototype.constructor = Cat1; <span class=\"comment\">// 再次提醒（自己）不要忘记了修正constructor属性</span></span><br></pre></td></tr></table></figure>\n<p>缺点： 子类原型指向父类，它没有自己独立的原型对象，所以当添加属性时会映射到父类，无法形成原型链。</p>\n<ul>\n<li>构造原型链法</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat2</span><span class=\"params\">(name, age, tailLength)</span></span> &#123;</span><br><span class=\"line\">  Animal.call(this, name, age);</span><br><span class=\"line\">  this.tailLength = tailLength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat2.prototype = Object.<span class=\"built_in\">create</span>(Animal.prototype);</span><br><span class=\"line\">Cat2.prototype.constructor = Cat2; // 注意这里并不是修正了，而是添加constructor属性，因为Cat2.prototype是个空对象，只有<span class=\"string\">[[prototypr]]</span>属性(__proto__)</span><br></pre></td></tr></table></figure>\n<p>缺点： 这种继承方式比较常见，缺点不怎么明显，本人暂时不知。</p>\n<ul>\n<li>拷贝继承<br>这个没写示例了（因为那啥，拷贝嘛，浅拷贝大家都懂，深拷贝我还得看看书去）<br>缺点： 共用方法会在后续的子类的原型中都存有一份拷贝，<strong>很浪费内存</strong>。假设第n代构造函数原型上有n个自己的共用方法，那么它原型上的共用方法有 1+2+3+……+n个。</li>\n</ul>\n<h3 id=\"ES6的继承\"><a href=\"#ES6的继承\" class=\"headerlink\" title=\"ES6的继承\"></a>ES6的继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  say() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`My name is <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> and I am <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.age&#125;</span> years old`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(school, ...rest) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(...rest);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.school = school;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getSchool() &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.school);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的原理和构造原型链继承十分相似，不同的是子类的__proto__属性会指向父类，ES5的继承是只有一条<strong>proto</strong>链的，它串联了构造函数的原型对象prototype。ES6里通过__proto__串联了2条链,如下：<br>Object.setPrototypeOf(Student, Person)<br>Object.setPrototypeOf(Student.prototype, Person.prototype)。</p>\n<h3 id=\"ES5继承和ES6的class区别\"><a href=\"#ES5继承和ES6的class区别\" class=\"headerlink\" title=\"ES5继承和ES6的class区别\"></a>ES5继承和ES6的class区别</h3><ol>\n<li>ES6可以继承内置类型，比如Array, Date, String等，ES5不行。</li>\n<li>ES6有两条链被__proto__串起，ES5只有1条。</li>\n</ol>\n<h3 id=\"总结：我真的理清楚了吗？\"><a href=\"#总结：我真的理清楚了吗？\" class=\"headerlink\" title=\"总结：我真的理清楚了吗？\"></a>总结：我真的理清楚了吗？</h3><p> ES5的继承还是理清头绪了的，但是ES6的还有如下疑问：</p>\n<ul>\n<li>ES6可以继承内置类型而ES5不行，如果ES6是语法糖，它都能实现的功能而ES5却不行，为什么？</li>\n<li>《ES6标准入门》里说ES6是先构造父类的this对象，父类里的this对象又是指向子类的（很疑惑），而ES5是先构造子函数的this，再通过上下文绑定实现，所以ES6的类语法真的只是封装ES5的继承的语法糖这么简单吗？</li>\n</ul>\n<p>这些问题当个记录了，下次自己来补答案。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>曾几何时，自己看过了多少篇的有关js继承的文章，原型链，继承这些挂在一起的概念，本以为自己已经理解了，但是最近再认真梳理时却发现： “原型链和继承， 剪不断，理还乱”。所以这次决定理清楚点。</p>\n<h3 id=\"原型链，-继承，-new关键字，本是一家人\"><a href=\"#原型链，-继承，-new关键字，本是一家人\" class=\"headerlink\" title=\"原型链， 继承， new关键字，本是一家人\"></a>原型链， 继承， new关键字，本是一家人</h3><p>为什么把这三个家伙归为一家人呢，因为js里有原型对象，原型对象被串成原型链，js的继承恰好是通过原型链实现的，而new关键字，则是继承的实例化操作者，它根据构造函数创建相应的对象，并且把对象与构造函数的原型（prototype）通过<strong>proto</strong>串起来了。ok，这个实例对象就是继承之后的体现了，它能访问原型链上的各种函数。所以说，原型链，继承，new是一家人，关系剪不断。</p>\n<h3 id=\"ES5的继承实现方法\"><a href=\"#ES5的继承实现方法\" class=\"headerlink\" title=\"ES5的继承实现方法\"></a>ES5的继承实现方法</h3><ul>\n<li>实例化法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.nameReverse = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实例化原型继承</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat0</span>(<span class=\"params\">name, age, tailLength</span>) </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, name, age);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tailLength = tailLength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat0.prototype = <span class=\"keyword\">new</span> Animal(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">Cat0.prototype.constructor = Cat0; <span class=\"comment\">// 不要忘记修正constructor属性</span></span><br></pre></td></tr></table></figure>\n<p>缺点： 此时Cat0.prototype.__proto__ === Animal.prototype,已经达到继承目的，但是在Cat0的prototype对象上产生了多余的父类实例属性</p>\n<ul>\n<li>直接引用法</li>\n</ul>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat1</span><span class=\"params\">(name, age, tailLength)</span> </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, name, age);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tailLength = tailLength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat1.prototype = Animal.prototype; </span><br><span class=\"line\">Cat1.prototype.constructor = Cat1; <span class=\"comment\">// 再次提醒（自己）不要忘记了修正constructor属性</span></span><br></pre></td></tr></table></figure>\n<p>缺点： 子类原型指向父类，它没有自己独立的原型对象，所以当添加属性时会映射到父类，无法形成原型链。</p>\n<ul>\n<li>构造原型链法</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat2</span><span class=\"params\">(name, age, tailLength)</span></span> &#123;</span><br><span class=\"line\">  Animal.call(this, name, age);</span><br><span class=\"line\">  this.tailLength = tailLength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat2.prototype = Object.<span class=\"built_in\">create</span>(Animal.prototype);</span><br><span class=\"line\">Cat2.prototype.constructor = Cat2; // 注意这里并不是修正了，而是添加constructor属性，因为Cat2.prototype是个空对象，只有<span class=\"string\">[[prototypr]]</span>属性(__proto__)</span><br></pre></td></tr></table></figure>\n<p>缺点： 这种继承方式比较常见，缺点不怎么明显，本人暂时不知。</p>\n<ul>\n<li>拷贝继承<br>这个没写示例了（因为那啥，拷贝嘛，浅拷贝大家都懂，深拷贝我还得看看书去）<br>缺点： 共用方法会在后续的子类的原型中都存有一份拷贝，<strong>很浪费内存</strong>。假设第n代构造函数原型上有n个自己的共用方法，那么它原型上的共用方法有 1+2+3+……+n个。</li>\n</ul>\n<h3 id=\"ES6的继承\"><a href=\"#ES6的继承\" class=\"headerlink\" title=\"ES6的继承\"></a>ES6的继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  say() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`My name is <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> and I am <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.age&#125;</span> years old`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(school, ...rest) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(...rest);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.school = school;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getSchool() &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.school);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的原理和构造原型链继承十分相似，不同的是子类的__proto__属性会指向父类，ES5的继承是只有一条<strong>proto</strong>链的，它串联了构造函数的原型对象prototype。ES6里通过__proto__串联了2条链,如下：<br>Object.setPrototypeOf(Student, Person)<br>Object.setPrototypeOf(Student.prototype, Person.prototype)。</p>\n<h3 id=\"ES5继承和ES6的class区别\"><a href=\"#ES5继承和ES6的class区别\" class=\"headerlink\" title=\"ES5继承和ES6的class区别\"></a>ES5继承和ES6的class区别</h3><ol>\n<li>ES6可以继承内置类型，比如Array, Date, String等，ES5不行。</li>\n<li>ES6有两条链被__proto__串起，ES5只有1条。</li>\n</ol>\n<h3 id=\"总结：我真的理清楚了吗？\"><a href=\"#总结：我真的理清楚了吗？\" class=\"headerlink\" title=\"总结：我真的理清楚了吗？\"></a>总结：我真的理清楚了吗？</h3><p> ES5的继承还是理清头绪了的，但是ES6的还有如下疑问：</p>\n<ul>\n<li>ES6可以继承内置类型而ES5不行，如果ES6是语法糖，它都能实现的功能而ES5却不行，为什么？</li>\n<li>《ES6标准入门》里说ES6是先构造父类的this对象，父类里的this对象又是指向子类的（很疑惑），而ES5是先构造子函数的this，再通过上下文绑定实现，所以ES6的类语法真的只是封装ES5的继承的语法糖这么简单吗？</li>\n</ul>\n<p>这些问题当个记录了，下次自己来补答案。</p>\n"},{"title":"proxy笔记","date":"2019-01-25T15:32:33.000Z","comments":1,"_content":"\n### 前言\nproxy，中文名叫代理，这很容易让人想到服务器的代理。比如正向代理，类似通过自己境外服务器搭的ssr获取围墙外面的网页，还有反向代理，大概意思应该是将收到的请求转发到不同的处理服务器。emmm，以上纯属是为了复习一下正反向代理的区别。今天要说的是ES6里的proxy。说到代理我还想到了java里的动态代理机制，在一个公众号里看过一篇相关文章，但是没看懂java的代理到底是怎么实现的，所以我也不知道ES6的proxy是不是参照了它的思想。\n\n### Proxy构造函数\n\n```\n    let obj = {};\n    let p = new Proxy(obj,{});  //接收2个参数，第一个是被代理的对象，第二个是代理配置，可以配置拦截函数\n    obj.count = 1;\n    p.count; // 上面拦截配置是空对象，所以没有拦截效果\n```\n\n其次，proxy实例与所代理的对象是没有直接联系的，所以要**通过proxy实例访问对象属性才有拦截效果**，\nproxy实例可以作为原型对象\n\n### Proxy的一些拦截方法\n - **get(target, prop[, receiver])**\n  拦截对象属性的读取，例如p.foo, p['foo']。\n - **set(target, prop, value[, receiver]): boolean**\n  拦截对象属性的设置，如p.foo = 1, p['foo'] = function() {}\n - **defineProperty(target, prop, propDesc): boolean**\n  拦截Object.defineProperty,Object.defineProperties。vue3.0版本之前的双向绑定就是通过Object.defineProperty实现的，不过3.0好像就要用proxy实现了，目测是拦截set方法吧。\n - **has(target, prop): boolean**\n  拦截 in 操作，prop in obj。\n - 其他待补充\n \n### proxy怎么用\n - 数据双向绑定，拦截set做视图更新\n - 实现私有属性，拦截get，如果访问的是下划线开头的属性则抛出错误，拦截has防止私有属性被for...in 遍历\n - web客户端数据请求的通用接口函数\n\n参照《ES6标准入门》代码：\n\n```\n    function createWebService(baseurl) {\n        return new Proxy({}, {\n            get: function(target, prop) {\n                return () => httpGet(`${baseurl}/prop`)\n            }\n        })\n    }\n    \n    const service = createWebService('http://127.0.0.1:8080')\n    service.fetchData().then(callback)\n```\n\n感觉通用接口函数的用法很妙啊，几行代码就搞定了从不同api获取数据的函数。\n\n### 补充\n<a href=\"https://github.com/fyyhome/Fvue/tree/feature-proxy\" target=\"_blank\" style=\"text-decoration: underline\">proxy替代defineProperty实现双向数据绑定</a><br><br>\n\n","source":"_posts/proxy笔记.md","raw":"---\ntitle: proxy笔记\ndate: 2019-01-25 23:32:33\ntags: js\ncomments: true\n---\n\n### 前言\nproxy，中文名叫代理，这很容易让人想到服务器的代理。比如正向代理，类似通过自己境外服务器搭的ssr获取围墙外面的网页，还有反向代理，大概意思应该是将收到的请求转发到不同的处理服务器。emmm，以上纯属是为了复习一下正反向代理的区别。今天要说的是ES6里的proxy。说到代理我还想到了java里的动态代理机制，在一个公众号里看过一篇相关文章，但是没看懂java的代理到底是怎么实现的，所以我也不知道ES6的proxy是不是参照了它的思想。\n\n### Proxy构造函数\n\n```\n    let obj = {};\n    let p = new Proxy(obj,{});  //接收2个参数，第一个是被代理的对象，第二个是代理配置，可以配置拦截函数\n    obj.count = 1;\n    p.count; // 上面拦截配置是空对象，所以没有拦截效果\n```\n\n其次，proxy实例与所代理的对象是没有直接联系的，所以要**通过proxy实例访问对象属性才有拦截效果**，\nproxy实例可以作为原型对象\n\n### Proxy的一些拦截方法\n - **get(target, prop[, receiver])**\n  拦截对象属性的读取，例如p.foo, p['foo']。\n - **set(target, prop, value[, receiver]): boolean**\n  拦截对象属性的设置，如p.foo = 1, p['foo'] = function() {}\n - **defineProperty(target, prop, propDesc): boolean**\n  拦截Object.defineProperty,Object.defineProperties。vue3.0版本之前的双向绑定就是通过Object.defineProperty实现的，不过3.0好像就要用proxy实现了，目测是拦截set方法吧。\n - **has(target, prop): boolean**\n  拦截 in 操作，prop in obj。\n - 其他待补充\n \n### proxy怎么用\n - 数据双向绑定，拦截set做视图更新\n - 实现私有属性，拦截get，如果访问的是下划线开头的属性则抛出错误，拦截has防止私有属性被for...in 遍历\n - web客户端数据请求的通用接口函数\n\n参照《ES6标准入门》代码：\n\n```\n    function createWebService(baseurl) {\n        return new Proxy({}, {\n            get: function(target, prop) {\n                return () => httpGet(`${baseurl}/prop`)\n            }\n        })\n    }\n    \n    const service = createWebService('http://127.0.0.1:8080')\n    service.fetchData().then(callback)\n```\n\n感觉通用接口函数的用法很妙啊，几行代码就搞定了从不同api获取数据的函数。\n\n### 补充\n<a href=\"https://github.com/fyyhome/Fvue/tree/feature-proxy\" target=\"_blank\" style=\"text-decoration: underline\">proxy替代defineProperty实现双向数据绑定</a><br><br>\n\n","slug":"proxy笔记","published":1,"updated":"2019-08-28T12:45:42.609Z","layout":"post","photos":[],"link":"","_id":"ck2a5oy4t000h01zzvrpzfx8c","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>proxy，中文名叫代理，这很容易让人想到服务器的代理。比如正向代理，类似通过自己境外服务器搭的ssr获取围墙外面的网页，还有反向代理，大概意思应该是将收到的请求转发到不同的处理服务器。emmm，以上纯属是为了复习一下正反向代理的区别。今天要说的是ES6里的proxy。说到代理我还想到了java里的动态代理机制，在一个公众号里看过一篇相关文章，但是没看懂java的代理到底是怎么实现的，所以我也不知道ES6的proxy是不是参照了它的思想。</p>\n<h3 id=\"Proxy构造函数\"><a href=\"#Proxy构造函数\" class=\"headerlink\" title=\"Proxy构造函数\"></a>Proxy构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(obj,&#123;&#125;);  <span class=\"comment\">//接收2个参数，第一个是被代理的对象，第二个是代理配置，可以配置拦截函数</span></span><br><span class=\"line\">obj.count = <span class=\"number\">1</span>;</span><br><span class=\"line\">p.count; <span class=\"comment\">// 上面拦截配置是空对象，所以没有拦截效果</span></span><br></pre></td></tr></table></figure>\n<p>其次，proxy实例与所代理的对象是没有直接联系的，所以要<strong>通过proxy实例访问对象属性才有拦截效果</strong>，<br>proxy实例可以作为原型对象</p>\n<h3 id=\"Proxy的一些拦截方法\"><a href=\"#Proxy的一些拦截方法\" class=\"headerlink\" title=\"Proxy的一些拦截方法\"></a>Proxy的一些拦截方法</h3><ul>\n<li><strong>get(target, prop[, receiver])</strong><br>拦截对象属性的读取，例如p.foo, p[‘foo’]。</li>\n<li><strong>set(target, prop, value[, receiver]): boolean</strong><br>拦截对象属性的设置，如p.foo = 1, p[‘foo’] = function() {}</li>\n<li><strong>defineProperty(target, prop, propDesc): boolean</strong><br>拦截Object.defineProperty,Object.defineProperties。vue3.0版本之前的双向绑定就是通过Object.defineProperty实现的，不过3.0好像就要用proxy实现了，目测是拦截set方法吧。</li>\n<li><strong>has(target, prop): boolean</strong><br>拦截 in 操作，prop in obj。</li>\n<li>其他待补充</li>\n</ul>\n<h3 id=\"proxy怎么用\"><a href=\"#proxy怎么用\" class=\"headerlink\" title=\"proxy怎么用\"></a>proxy怎么用</h3><ul>\n<li>数据双向绑定，拦截set做视图更新</li>\n<li>实现私有属性，拦截get，如果访问的是下划线开头的属性则抛出错误，拦截has防止私有属性被for…in 遍历</li>\n<li>web客户端数据请求的通用接口函数</li>\n</ul>\n<p>参照《ES6标准入门》代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createWebService</span>(<span class=\"params\">baseurl</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, prop</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> httpGet(<span class=\"string\">`<span class=\"subst\">$&#123;baseurl&#125;</span>/prop`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> service = createWebService(<span class=\"string\">'http://127.0.0.1:8080'</span>)</span><br><span class=\"line\">service.fetchData().then(callback)</span><br></pre></td></tr></table></figure>\n<p>感觉通用接口函数的用法很妙啊，几行代码就搞定了从不同api获取数据的函数。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p><a href=\"https://github.com/fyyhome/Fvue/tree/feature-proxy\" target=\"_blank\" style=\"text-decoration: underline\">proxy替代defineProperty实现双向数据绑定</a><br><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>proxy，中文名叫代理，这很容易让人想到服务器的代理。比如正向代理，类似通过自己境外服务器搭的ssr获取围墙外面的网页，还有反向代理，大概意思应该是将收到的请求转发到不同的处理服务器。emmm，以上纯属是为了复习一下正反向代理的区别。今天要说的是ES6里的proxy。说到代理我还想到了java里的动态代理机制，在一个公众号里看过一篇相关文章，但是没看懂java的代理到底是怎么实现的，所以我也不知道ES6的proxy是不是参照了它的思想。</p>\n<h3 id=\"Proxy构造函数\"><a href=\"#Proxy构造函数\" class=\"headerlink\" title=\"Proxy构造函数\"></a>Proxy构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(obj,&#123;&#125;);  <span class=\"comment\">//接收2个参数，第一个是被代理的对象，第二个是代理配置，可以配置拦截函数</span></span><br><span class=\"line\">obj.count = <span class=\"number\">1</span>;</span><br><span class=\"line\">p.count; <span class=\"comment\">// 上面拦截配置是空对象，所以没有拦截效果</span></span><br></pre></td></tr></table></figure>\n<p>其次，proxy实例与所代理的对象是没有直接联系的，所以要<strong>通过proxy实例访问对象属性才有拦截效果</strong>，<br>proxy实例可以作为原型对象</p>\n<h3 id=\"Proxy的一些拦截方法\"><a href=\"#Proxy的一些拦截方法\" class=\"headerlink\" title=\"Proxy的一些拦截方法\"></a>Proxy的一些拦截方法</h3><ul>\n<li><strong>get(target, prop[, receiver])</strong><br>拦截对象属性的读取，例如p.foo, p[‘foo’]。</li>\n<li><strong>set(target, prop, value[, receiver]): boolean</strong><br>拦截对象属性的设置，如p.foo = 1, p[‘foo’] = function() {}</li>\n<li><strong>defineProperty(target, prop, propDesc): boolean</strong><br>拦截Object.defineProperty,Object.defineProperties。vue3.0版本之前的双向绑定就是通过Object.defineProperty实现的，不过3.0好像就要用proxy实现了，目测是拦截set方法吧。</li>\n<li><strong>has(target, prop): boolean</strong><br>拦截 in 操作，prop in obj。</li>\n<li>其他待补充</li>\n</ul>\n<h3 id=\"proxy怎么用\"><a href=\"#proxy怎么用\" class=\"headerlink\" title=\"proxy怎么用\"></a>proxy怎么用</h3><ul>\n<li>数据双向绑定，拦截set做视图更新</li>\n<li>实现私有属性，拦截get，如果访问的是下划线开头的属性则抛出错误，拦截has防止私有属性被for…in 遍历</li>\n<li>web客户端数据请求的通用接口函数</li>\n</ul>\n<p>参照《ES6标准入门》代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createWebService</span>(<span class=\"params\">baseurl</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, prop</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> httpGet(<span class=\"string\">`<span class=\"subst\">$&#123;baseurl&#125;</span>/prop`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> service = createWebService(<span class=\"string\">'http://127.0.0.1:8080'</span>)</span><br><span class=\"line\">service.fetchData().then(callback)</span><br></pre></td></tr></table></figure>\n<p>感觉通用接口函数的用法很妙啊，几行代码就搞定了从不同api获取数据的函数。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p><a href=\"https://github.com/fyyhome/Fvue/tree/feature-proxy\" target=\"_blank\" style=\"text-decoration: underline\">proxy替代defineProperty实现双向数据绑定</a><br><br></p>\n"},{"title":"js之Set和Map结构","date":"2019-01-24T15:36:49.000Z","comments":1,"_content":"\n### 前言\n重读es6标准入门，补写笔记\n\n### Set\nSet是种类似数组的结构，可用for...of直接遍历，也可以用...展开。，但是它里面的元素不能重复（类似不能有===关系，但NaN!==NaN,Set里它和自身是相等的）。\n\n - 初始化\n > let s = new Set();\nlet s = new Set([1,2,3]);传入具有itreable接口的结构都行，，常见为数组\n\n - 常用方法\n > 1. add(value): Set\n > 2. delete(value): boolean\n > 3. has(value): boolean\n > 4. clear(): void\n > ———————————遍历方法(遍历顺序就是插入顺序，类似队列)———————————\n > 5. keys()\n > 6. values()//Set的默认遍历器生成函数，所以可以直接for...of(扩展运算符内部使用的也是for...of)\n > 7. entries()\n > 8. forEach(callback)\n\n数组去重：[...new Set([1,2,3,1])];// [1,2,3]\nSet转数组：Array.from(set)或者直接[...set]\n\n### Map\nMap是一种值对值的数据结构，相比对象的键值对，它的键可以是任和类型的值，不局限于字符串。\n\n - 初始化\n > let m = new Map();\nlet m = new Map([['val1','val2']]);由键值对数组组成的数组初始化\n\n - 常用方法\n > 1.set(key,value)\n2.get(key)\n3.has(key)\n4.delete(key)\n5.clear()\n遍历方法和Set一样，另外2个都有size属性表示大小。\n\n - Map与对象，json对象，json数组的相互转换，留着用到的时候填坑-_-\n","source":"_posts/js之Set和Map结构.md","raw":"---\ntitle: js之Set和Map结构\ndate: 2019-01-24 23:36:49\ntags: js\ncomments: true\n---\n\n### 前言\n重读es6标准入门，补写笔记\n\n### Set\nSet是种类似数组的结构，可用for...of直接遍历，也可以用...展开。，但是它里面的元素不能重复（类似不能有===关系，但NaN!==NaN,Set里它和自身是相等的）。\n\n - 初始化\n > let s = new Set();\nlet s = new Set([1,2,3]);传入具有itreable接口的结构都行，，常见为数组\n\n - 常用方法\n > 1. add(value): Set\n > 2. delete(value): boolean\n > 3. has(value): boolean\n > 4. clear(): void\n > ———————————遍历方法(遍历顺序就是插入顺序，类似队列)———————————\n > 5. keys()\n > 6. values()//Set的默认遍历器生成函数，所以可以直接for...of(扩展运算符内部使用的也是for...of)\n > 7. entries()\n > 8. forEach(callback)\n\n数组去重：[...new Set([1,2,3,1])];// [1,2,3]\nSet转数组：Array.from(set)或者直接[...set]\n\n### Map\nMap是一种值对值的数据结构，相比对象的键值对，它的键可以是任和类型的值，不局限于字符串。\n\n - 初始化\n > let m = new Map();\nlet m = new Map([['val1','val2']]);由键值对数组组成的数组初始化\n\n - 常用方法\n > 1.set(key,value)\n2.get(key)\n3.has(key)\n4.delete(key)\n5.clear()\n遍历方法和Set一样，另外2个都有size属性表示大小。\n\n - Map与对象，json对象，json数组的相互转换，留着用到的时候填坑-_-\n","slug":"js之Set和Map结构","published":1,"updated":"2019-08-28T12:45:36.286Z","layout":"post","photos":[],"link":"","_id":"ck2a5oy4v000l01zz1g3vvlm2","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>重读es6标准入门，补写笔记</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set是种类似数组的结构，可用for…of直接遍历，也可以用…展开。，但是它里面的元素不能重复（类似不能有===关系，但NaN!==NaN,Set里它和自身是相等的）。</p>\n<ul>\n<li><p>初始化</p>\n<blockquote>\n<p>let s = new Set();<br>let s = new Set([1,2,3]);传入具有itreable接口的结构都行，，常见为数组</p>\n</blockquote>\n</li>\n<li><p>常用方法</p>\n<blockquote>\n<ol>\n<li>add(value): Set</li>\n<li>delete(value): boolean</li>\n<li>has(value): boolean</li>\n<li>clear(): void<br>———————————遍历方法(遍历顺序就是插入顺序，类似队列)———————————</li>\n<li>keys()</li>\n<li>values()//Set的默认遍历器生成函数，所以可以直接for…of(扩展运算符内部使用的也是for…of)</li>\n<li>entries()</li>\n<li>forEach(callback)</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p>数组去重：[…new Set([1,2,3,1])];// [1,2,3]<br>Set转数组：Array.from(set)或者直接[…set]</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map是一种值对值的数据结构，相比对象的键值对，它的键可以是任和类型的值，不局限于字符串。</p>\n<ul>\n<li><p>初始化</p>\n<blockquote>\n<p>let m = new Map();<br>let m = new Map([[‘val1’,’val2’]]);由键值对数组组成的数组初始化</p>\n</blockquote>\n</li>\n<li><p>常用方法</p>\n<blockquote>\n<p>1.set(key,value)<br>2.get(key)<br>3.has(key)<br>4.delete(key)<br>5.clear()<br>遍历方法和Set一样，另外2个都有size属性表示大小。</p>\n</blockquote>\n</li>\n<li><p>Map与对象，json对象，json数组的相互转换，留着用到的时候填坑-_-</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>重读es6标准入门，补写笔记</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set是种类似数组的结构，可用for…of直接遍历，也可以用…展开。，但是它里面的元素不能重复（类似不能有===关系，但NaN!==NaN,Set里它和自身是相等的）。</p>\n<ul>\n<li><p>初始化</p>\n<blockquote>\n<p>let s = new Set();<br>let s = new Set([1,2,3]);传入具有itreable接口的结构都行，，常见为数组</p>\n</blockquote>\n</li>\n<li><p>常用方法</p>\n<blockquote>\n<ol>\n<li>add(value): Set</li>\n<li>delete(value): boolean</li>\n<li>has(value): boolean</li>\n<li>clear(): void<br>———————————遍历方法(遍历顺序就是插入顺序，类似队列)———————————</li>\n<li>keys()</li>\n<li>values()//Set的默认遍历器生成函数，所以可以直接for…of(扩展运算符内部使用的也是for…of)</li>\n<li>entries()</li>\n<li>forEach(callback)</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p>数组去重：[…new Set([1,2,3,1])];// [1,2,3]<br>Set转数组：Array.from(set)或者直接[…set]</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map是一种值对值的数据结构，相比对象的键值对，它的键可以是任和类型的值，不局限于字符串。</p>\n<ul>\n<li><p>初始化</p>\n<blockquote>\n<p>let m = new Map();<br>let m = new Map([[‘val1’,’val2’]]);由键值对数组组成的数组初始化</p>\n</blockquote>\n</li>\n<li><p>常用方法</p>\n<blockquote>\n<p>1.set(key,value)<br>2.get(key)<br>3.has(key)<br>4.delete(key)<br>5.clear()<br>遍历方法和Set一样，另外2个都有size属性表示大小。</p>\n</blockquote>\n</li>\n<li><p>Map与对象，json对象，json数组的相互转换，留着用到的时候填坑-_-</p>\n</li>\n</ul>\n"},{"title":"浅谈浏览器复制内容到剪切板","date":"2018-10-28T02:33:02.000Z","_content":"\n### 前言\n这几天淘宝点赞集能量的口令漫天飞舞，我当然也凑凑这个热闹，但是在各大群转发口令显然不是我一贯的风格。于是我就发现，这不就是在csdn会经常看到的么：“*内容已复制到剪切板，请求打开淘宝*”。我就想啊，要是能在哪个访问量高的网站注入一段这种脚本，把自己的点赞口令放进去，（hahahhahahahahaha）有意思。但是注入脚本还是有点难度的，毕竟现在网站的防范意识比较强。不过在自己的博客上搞搞这个还行，权当娱乐一下。\n\n### 正文\n  这里主要用到2个api\n  #### document.execCommand\n  先看看mdn文档，这个api主要是用命令来操纵可编辑区域的内容。\n  *bool = document.execCommand(命令string：aCommandName, 是否展示用户界面Boolean: aShowDefaultUI, 命令的额外参数： aValueArgument)*\n  至于具体有哪些命令就看mdn了，我就不搬过来了。复制主要用到*copy*命令。*另外可以用document.queryCommandSupported(command)查询指令是否支持*\n  copy: 拷贝当前选中的内容到剪切板\n  #### HTMLInputElement.setSelectionRange()\n  既然要拷贝当前选中的内容，当然就要让那个元素focus一下咯。然后就用到这个api来选择要复制全部还是某一小部分呢，它从被focus的元素中选中特定的内容。\n  inputElement.setSelectionRange(selectionStart, selectionEnd, [optional] selectionDirection)，三个参数，分别是复制开始位置，结束位置(mdn上的demo说-1是最后一个位置，但是我的华为自带浏览器貌似不认这个，建议textNode.value.length)，复制的方向（可选）。\n\n  #### 从浏览器调起APP\n  首先你要知道那个APP的scheme url，例如淘宝： taobao://，后面加上相关页面的参数就行，如taobao://item.taobao.com/item.html?id=41700658839。\n  然后可以用iframe的src调起或者window.location也行。\n\n### 下面是简单的测试代码\n<input type=\"text\" name=\"kouling\" id=\"text1\" value=\"测试!!!!\">\n<input type=\"button\" name=\"ensure\" id=\"btn1\" value=\"复制到剪切板\">\n<!-- <iframe src=\"taobao://item.taobao.com/item.html?id=41700658839\"></iframe> -->\n\n<script>\n  let btn = document.getElementById(\"btn1\");\n  let textNode = document.getElementById(\"text1\");\n  btn.addEventListener(\"click\", function() {\n    if(textNode.value) {\n      textNode.focus();\n      textNode.setSelectionRange(0,textNode.value.length);\n      document.execCommand(\"copy\",false);\n    }\n  });\n  // window.location.href=\"taobao://item.taobao.com/item.html?id=41700658839\";\n</script>","source":"_posts/浅谈浏览器复制内容到剪切板.md","raw":"---\ntitle: 浅谈浏览器复制内容到剪切板\ndate: 2018-10-28 10:33:02\ntags: js\ncategory: 技术\n---\n\n### 前言\n这几天淘宝点赞集能量的口令漫天飞舞，我当然也凑凑这个热闹，但是在各大群转发口令显然不是我一贯的风格。于是我就发现，这不就是在csdn会经常看到的么：“*内容已复制到剪切板，请求打开淘宝*”。我就想啊，要是能在哪个访问量高的网站注入一段这种脚本，把自己的点赞口令放进去，（hahahhahahahahaha）有意思。但是注入脚本还是有点难度的，毕竟现在网站的防范意识比较强。不过在自己的博客上搞搞这个还行，权当娱乐一下。\n\n### 正文\n  这里主要用到2个api\n  #### document.execCommand\n  先看看mdn文档，这个api主要是用命令来操纵可编辑区域的内容。\n  *bool = document.execCommand(命令string：aCommandName, 是否展示用户界面Boolean: aShowDefaultUI, 命令的额外参数： aValueArgument)*\n  至于具体有哪些命令就看mdn了，我就不搬过来了。复制主要用到*copy*命令。*另外可以用document.queryCommandSupported(command)查询指令是否支持*\n  copy: 拷贝当前选中的内容到剪切板\n  #### HTMLInputElement.setSelectionRange()\n  既然要拷贝当前选中的内容，当然就要让那个元素focus一下咯。然后就用到这个api来选择要复制全部还是某一小部分呢，它从被focus的元素中选中特定的内容。\n  inputElement.setSelectionRange(selectionStart, selectionEnd, [optional] selectionDirection)，三个参数，分别是复制开始位置，结束位置(mdn上的demo说-1是最后一个位置，但是我的华为自带浏览器貌似不认这个，建议textNode.value.length)，复制的方向（可选）。\n\n  #### 从浏览器调起APP\n  首先你要知道那个APP的scheme url，例如淘宝： taobao://，后面加上相关页面的参数就行，如taobao://item.taobao.com/item.html?id=41700658839。\n  然后可以用iframe的src调起或者window.location也行。\n\n### 下面是简单的测试代码\n<input type=\"text\" name=\"kouling\" id=\"text1\" value=\"测试!!!!\">\n<input type=\"button\" name=\"ensure\" id=\"btn1\" value=\"复制到剪切板\">\n<!-- <iframe src=\"taobao://item.taobao.com/item.html?id=41700658839\"></iframe> -->\n\n<script>\n  let btn = document.getElementById(\"btn1\");\n  let textNode = document.getElementById(\"text1\");\n  btn.addEventListener(\"click\", function() {\n    if(textNode.value) {\n      textNode.focus();\n      textNode.setSelectionRange(0,textNode.value.length);\n      document.execCommand(\"copy\",false);\n    }\n  });\n  // window.location.href=\"taobao://item.taobao.com/item.html?id=41700658839\";\n</script>","slug":"浅谈浏览器复制内容到剪切板","published":1,"updated":"2019-08-28T12:45:02.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2a5oy4w000n01zzampnmrn7","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这几天淘宝点赞集能量的口令漫天飞舞，我当然也凑凑这个热闹，但是在各大群转发口令显然不是我一贯的风格。于是我就发现，这不就是在csdn会经常看到的么：“<em>内容已复制到剪切板，请求打开淘宝</em>”。我就想啊，要是能在哪个访问量高的网站注入一段这种脚本，把自己的点赞口令放进去，（hahahhahahahahaha）有意思。但是注入脚本还是有点难度的，毕竟现在网站的防范意识比较强。不过在自己的博客上搞搞这个还行，权当娱乐一下。</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>  这里主要用到2个api</p>\n<h4 id=\"document-execCommand\"><a href=\"#document-execCommand\" class=\"headerlink\" title=\"document.execCommand\"></a>document.execCommand</h4><p>  先看看mdn文档，这个api主要是用命令来操纵可编辑区域的内容。<br>  <em>bool = document.execCommand(命令string：aCommandName, 是否展示用户界面Boolean: aShowDefaultUI, 命令的额外参数： aValueArgument)</em><br>  至于具体有哪些命令就看mdn了，我就不搬过来了。复制主要用到<em>copy</em>命令。<em>另外可以用document.queryCommandSupported(command)查询指令是否支持</em><br>  copy: 拷贝当前选中的内容到剪切板</p>\n<h4 id=\"HTMLInputElement-setSelectionRange\"><a href=\"#HTMLInputElement-setSelectionRange\" class=\"headerlink\" title=\"HTMLInputElement.setSelectionRange()\"></a>HTMLInputElement.setSelectionRange()</h4><p>  既然要拷贝当前选中的内容，当然就要让那个元素focus一下咯。然后就用到这个api来选择要复制全部还是某一小部分呢，它从被focus的元素中选中特定的内容。<br>  inputElement.setSelectionRange(selectionStart, selectionEnd, [optional] selectionDirection)，三个参数，分别是复制开始位置，结束位置(mdn上的demo说-1是最后一个位置，但是我的华为自带浏览器貌似不认这个，建议textNode.value.length)，复制的方向（可选）。</p>\n<h4 id=\"从浏览器调起APP\"><a href=\"#从浏览器调起APP\" class=\"headerlink\" title=\"从浏览器调起APP\"></a>从浏览器调起APP</h4><p>  首先你要知道那个APP的scheme url，例如淘宝： taobao://，后面加上相关页面的参数就行，如taobao://item.taobao.com/item.html?id=41700658839。<br>  然后可以用iframe的src调起或者window.location也行。</p>\n<h3 id=\"下面是简单的测试代码\"><a href=\"#下面是简单的测试代码\" class=\"headerlink\" title=\"下面是简单的测试代码\"></a>下面是简单的测试代码</h3><p><input type=\"text\" name=\"kouling\" id=\"text1\" value=\"测试!!!!\"></p>\n<p><input type=\"button\" name=\"ensure\" id=\"btn1\" value=\"复制到剪切板\"><br><!-- <iframe src=\"taobao://item.taobao.com/item.html?id=41700658839\"></iframe> --></p>\n<script>\n  let btn = document.getElementById(\"btn1\");\n  let textNode = document.getElementById(\"text1\");\n  btn.addEventListener(\"click\", function() {\n    if(textNode.value) {\n      textNode.focus();\n      textNode.setSelectionRange(0,textNode.value.length);\n      document.execCommand(\"copy\",false);\n    }\n  });\n  // window.location.href=\"taobao://item.taobao.com/item.html?id=41700658839\";\n</script>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这几天淘宝点赞集能量的口令漫天飞舞，我当然也凑凑这个热闹，但是在各大群转发口令显然不是我一贯的风格。于是我就发现，这不就是在csdn会经常看到的么：“<em>内容已复制到剪切板，请求打开淘宝</em>”。我就想啊，要是能在哪个访问量高的网站注入一段这种脚本，把自己的点赞口令放进去，（hahahhahahahahaha）有意思。但是注入脚本还是有点难度的，毕竟现在网站的防范意识比较强。不过在自己的博客上搞搞这个还行，权当娱乐一下。</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>  这里主要用到2个api</p>\n<h4 id=\"document-execCommand\"><a href=\"#document-execCommand\" class=\"headerlink\" title=\"document.execCommand\"></a>document.execCommand</h4><p>  先看看mdn文档，这个api主要是用命令来操纵可编辑区域的内容。<br>  <em>bool = document.execCommand(命令string：aCommandName, 是否展示用户界面Boolean: aShowDefaultUI, 命令的额外参数： aValueArgument)</em><br>  至于具体有哪些命令就看mdn了，我就不搬过来了。复制主要用到<em>copy</em>命令。<em>另外可以用document.queryCommandSupported(command)查询指令是否支持</em><br>  copy: 拷贝当前选中的内容到剪切板</p>\n<h4 id=\"HTMLInputElement-setSelectionRange\"><a href=\"#HTMLInputElement-setSelectionRange\" class=\"headerlink\" title=\"HTMLInputElement.setSelectionRange()\"></a>HTMLInputElement.setSelectionRange()</h4><p>  既然要拷贝当前选中的内容，当然就要让那个元素focus一下咯。然后就用到这个api来选择要复制全部还是某一小部分呢，它从被focus的元素中选中特定的内容。<br>  inputElement.setSelectionRange(selectionStart, selectionEnd, [optional] selectionDirection)，三个参数，分别是复制开始位置，结束位置(mdn上的demo说-1是最后一个位置，但是我的华为自带浏览器貌似不认这个，建议textNode.value.length)，复制的方向（可选）。</p>\n<h4 id=\"从浏览器调起APP\"><a href=\"#从浏览器调起APP\" class=\"headerlink\" title=\"从浏览器调起APP\"></a>从浏览器调起APP</h4><p>  首先你要知道那个APP的scheme url，例如淘宝： taobao://，后面加上相关页面的参数就行，如taobao://item.taobao.com/item.html?id=41700658839。<br>  然后可以用iframe的src调起或者window.location也行。</p>\n<h3 id=\"下面是简单的测试代码\"><a href=\"#下面是简单的测试代码\" class=\"headerlink\" title=\"下面是简单的测试代码\"></a>下面是简单的测试代码</h3><p><input type=\"text\" name=\"kouling\" id=\"text1\" value=\"测试!!!!\"></p>\n<p><input type=\"button\" name=\"ensure\" id=\"btn1\" value=\"复制到剪切板\"><br><!-- <iframe src=\"taobao://item.taobao.com/item.html?id=41700658839\"></iframe> --></p>\n<script>\n  let btn = document.getElementById(\"btn1\");\n  let textNode = document.getElementById(\"text1\");\n  btn.addEventListener(\"click\", function() {\n    if(textNode.value) {\n      textNode.focus();\n      textNode.setSelectionRange(0,textNode.value.length);\n      document.execCommand(\"copy\",false);\n    }\n  });\n  // window.location.href=\"taobao://item.taobao.com/item.html?id=41700658839\";\n</script>"},{"title":"理解事件循环机制---EventLoop","date":"2019-02-28T04:41:19.000Z","_content":"\n### 前言\njavascript是一门单线程语言，处理很多耗时任务时如果只用一个线程就很容易发生阻塞，浏览器执行js时是怎么避免的呢？为什么js不设计成多线程语言呢？可能是因为js设计者最初的想法是让js简单，易用，也可能是因为要操作dom的原因，试想如果有2个线程并行，一个删除dom元素，一个修改同一dom元素，到底执行谁呢？ 感觉有点像数据库并发的脏读一样。为了加深对js执行时的理解，就有了下面的文章。\n\n### 什么是事件循环\n浏览器端获取到js代码后，会把变量存在堆里，对象指针存在栈里，然后一段一段运行执行栈里代码，遇到异步任务时，将任务挂起，继续执行后面的同步代码。挂起的异步任务在有了返回结果后会把返回结果（通常是回调函数）放入任务队列，任务队列有分为微任务队列和宏任务队列， 当执行栈中的任务都被执行完了，主进程空闲状态，它就会从微任务队列中把任务依次取到执行栈中执行，如果微任务队列为空，则从宏任务队列中取，执行栈执行完后为空，继续从任务队列取任务，如此循环。\n\n网上引了一张图：\n  {% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/eventloop.png %}\n\n### 哪些是异步任务\njs是单线程，但是浏览器是多线程的，它有不同的模块用于处理不同的异步任务，所以异步任务又可以细分三种\n\n - dom事件：当被监听的事件触发后，浏览器立即把回调函数加入宏任务队列。\n - setTimeout,setInterval: 到达指定时间点后把回调加入宏任务队列。\n - promise：resolve后把回调加入微任务队列。\n\n前两者是属于宏任务队列，而es6中的promise是属于微任务队列。\n\n### 通过代码理解事件循环\n看到好的题目再贴\n\n### 总结\n要理解的东西\n\n - 事件循环机制\n - 执行栈与任务队列\n - 宏任务与微任务","source":"_posts/理解事件循环机制-EventLoop.md","raw":"---\ntitle: 理解事件循环机制---EventLoop\ndate: 2019-02-28 12:41:19\ntags: js\n---\n\n### 前言\njavascript是一门单线程语言，处理很多耗时任务时如果只用一个线程就很容易发生阻塞，浏览器执行js时是怎么避免的呢？为什么js不设计成多线程语言呢？可能是因为js设计者最初的想法是让js简单，易用，也可能是因为要操作dom的原因，试想如果有2个线程并行，一个删除dom元素，一个修改同一dom元素，到底执行谁呢？ 感觉有点像数据库并发的脏读一样。为了加深对js执行时的理解，就有了下面的文章。\n\n### 什么是事件循环\n浏览器端获取到js代码后，会把变量存在堆里，对象指针存在栈里，然后一段一段运行执行栈里代码，遇到异步任务时，将任务挂起，继续执行后面的同步代码。挂起的异步任务在有了返回结果后会把返回结果（通常是回调函数）放入任务队列，任务队列有分为微任务队列和宏任务队列， 当执行栈中的任务都被执行完了，主进程空闲状态，它就会从微任务队列中把任务依次取到执行栈中执行，如果微任务队列为空，则从宏任务队列中取，执行栈执行完后为空，继续从任务队列取任务，如此循环。\n\n网上引了一张图：\n  {% img https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/eventloop.png %}\n\n### 哪些是异步任务\njs是单线程，但是浏览器是多线程的，它有不同的模块用于处理不同的异步任务，所以异步任务又可以细分三种\n\n - dom事件：当被监听的事件触发后，浏览器立即把回调函数加入宏任务队列。\n - setTimeout,setInterval: 到达指定时间点后把回调加入宏任务队列。\n - promise：resolve后把回调加入微任务队列。\n\n前两者是属于宏任务队列，而es6中的promise是属于微任务队列。\n\n### 通过代码理解事件循环\n看到好的题目再贴\n\n### 总结\n要理解的东西\n\n - 事件循环机制\n - 执行栈与任务队列\n - 宏任务与微任务","slug":"理解事件循环机制-EventLoop","published":1,"updated":"2019-08-28T12:44:58.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2a5oy51000u01zztsz47icj","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>javascript是一门单线程语言，处理很多耗时任务时如果只用一个线程就很容易发生阻塞，浏览器执行js时是怎么避免的呢？为什么js不设计成多线程语言呢？可能是因为js设计者最初的想法是让js简单，易用，也可能是因为要操作dom的原因，试想如果有2个线程并行，一个删除dom元素，一个修改同一dom元素，到底执行谁呢？ 感觉有点像数据库并发的脏读一样。为了加深对js执行时的理解，就有了下面的文章。</p>\n<h3 id=\"什么是事件循环\"><a href=\"#什么是事件循环\" class=\"headerlink\" title=\"什么是事件循环\"></a>什么是事件循环</h3><p>浏览器端获取到js代码后，会把变量存在堆里，对象指针存在栈里，然后一段一段运行执行栈里代码，遇到异步任务时，将任务挂起，继续执行后面的同步代码。挂起的异步任务在有了返回结果后会把返回结果（通常是回调函数）放入任务队列，任务队列有分为微任务队列和宏任务队列， 当执行栈中的任务都被执行完了，主进程空闲状态，它就会从微任务队列中把任务依次取到执行栈中执行，如果微任务队列为空，则从宏任务队列中取，执行栈执行完后为空，继续从任务队列取任务，如此循环。</p>\n<p>网上引了一张图：<br>  <img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/eventloop.png\"></p>\n<h3 id=\"哪些是异步任务\"><a href=\"#哪些是异步任务\" class=\"headerlink\" title=\"哪些是异步任务\"></a>哪些是异步任务</h3><p>js是单线程，但是浏览器是多线程的，它有不同的模块用于处理不同的异步任务，所以异步任务又可以细分三种</p>\n<ul>\n<li>dom事件：当被监听的事件触发后，浏览器立即把回调函数加入宏任务队列。</li>\n<li>setTimeout,setInterval: 到达指定时间点后把回调加入宏任务队列。</li>\n<li>promise：resolve后把回调加入微任务队列。</li>\n</ul>\n<p>前两者是属于宏任务队列，而es6中的promise是属于微任务队列。</p>\n<h3 id=\"通过代码理解事件循环\"><a href=\"#通过代码理解事件循环\" class=\"headerlink\" title=\"通过代码理解事件循环\"></a>通过代码理解事件循环</h3><p>看到好的题目再贴</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>要理解的东西</p>\n<ul>\n<li>事件循环机制</li>\n<li>执行栈与任务队列</li>\n<li>宏任务与微任务</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>javascript是一门单线程语言，处理很多耗时任务时如果只用一个线程就很容易发生阻塞，浏览器执行js时是怎么避免的呢？为什么js不设计成多线程语言呢？可能是因为js设计者最初的想法是让js简单，易用，也可能是因为要操作dom的原因，试想如果有2个线程并行，一个删除dom元素，一个修改同一dom元素，到底执行谁呢？ 感觉有点像数据库并发的脏读一样。为了加深对js执行时的理解，就有了下面的文章。</p>\n<h3 id=\"什么是事件循环\"><a href=\"#什么是事件循环\" class=\"headerlink\" title=\"什么是事件循环\"></a>什么是事件循环</h3><p>浏览器端获取到js代码后，会把变量存在堆里，对象指针存在栈里，然后一段一段运行执行栈里代码，遇到异步任务时，将任务挂起，继续执行后面的同步代码。挂起的异步任务在有了返回结果后会把返回结果（通常是回调函数）放入任务队列，任务队列有分为微任务队列和宏任务队列， 当执行栈中的任务都被执行完了，主进程空闲状态，它就会从微任务队列中把任务依次取到执行栈中执行，如果微任务队列为空，则从宏任务队列中取，执行栈执行完后为空，继续从任务队列取任务，如此循环。</p>\n<p>网上引了一张图：<br>  <img src=\"https://coding.net/u/home-fyy/p/blog_images/git/raw/master/code_images/eventloop.png\"></p>\n<h3 id=\"哪些是异步任务\"><a href=\"#哪些是异步任务\" class=\"headerlink\" title=\"哪些是异步任务\"></a>哪些是异步任务</h3><p>js是单线程，但是浏览器是多线程的，它有不同的模块用于处理不同的异步任务，所以异步任务又可以细分三种</p>\n<ul>\n<li>dom事件：当被监听的事件触发后，浏览器立即把回调函数加入宏任务队列。</li>\n<li>setTimeout,setInterval: 到达指定时间点后把回调加入宏任务队列。</li>\n<li>promise：resolve后把回调加入微任务队列。</li>\n</ul>\n<p>前两者是属于宏任务队列，而es6中的promise是属于微任务队列。</p>\n<h3 id=\"通过代码理解事件循环\"><a href=\"#通过代码理解事件循环\" class=\"headerlink\" title=\"通过代码理解事件循环\"></a>通过代码理解事件循环</h3><p>看到好的题目再贴</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>要理解的东西</p>\n<ul>\n<li>事件循环机制</li>\n<li>执行栈与任务队列</li>\n<li>宏任务与微任务</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck2a5oy4i000401zzin193rno","category_id":"ck2a5oy4k000601zzdxzm8fpa","_id":"ck2a5oy4u000i01zzygzzafti"},{"post_id":"ck2a5oy4w000n01zzampnmrn7","category_id":"ck2a5oy4k000601zzdxzm8fpa","_id":"ck2a5oy4y000r01zz8rrnlkc1"}],"PostTag":[{"post_id":"ck2a5oy4j000501zz7umm8g2j","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4n000901zz0t1hrows"},{"post_id":"ck2a5oy48000101zzr4rvvh31","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4p000b01zztg3uac5e"},{"post_id":"ck2a5oy4o000a01zzuoxztqnf","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4q000e01zzpw64gf4n"},{"post_id":"ck2a5oy4d000201zzth6rw4hv","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4t000g01zzbqqimwlx"},{"post_id":"ck2a5oy4p000c01zzyvevm93i","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4v000k01zz91qjxnxa"},{"post_id":"ck2a5oy4q000f01zz4grxu41q","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4w000m01zz1c0sp1ny"},{"post_id":"ck2a5oy4i000401zzin193rno","tag_id":"ck2a5oy4q000d01zz3c6sv5tk","_id":"ck2a5oy4x000o01zznpoewbne"},{"post_id":"ck2a5oy4t000h01zzvrpzfx8c","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4y000p01zz7e7b4aop"},{"post_id":"ck2a5oy4v000l01zz1g3vvlm2","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4y000q01zz3phgqbu2"},{"post_id":"ck2a5oy4l000701zz3nignjw6","tag_id":"ck2a5oy4u000j01zzejsoi8uz","_id":"ck2a5oy4y000s01zz2il52fqn"},{"post_id":"ck2a5oy4w000n01zzampnmrn7","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy4y000t01zz1af2gel0"},{"post_id":"ck2a5oy51000u01zztsz47icj","tag_id":"ck2a5oy4f000301zzopqsqgr2","_id":"ck2a5oy52000v01zzytkqe93v"}],"Tag":[{"name":"js","_id":"ck2a5oy4f000301zzopqsqgr2"},{"name":"docker","_id":"ck2a5oy4q000d01zz3c6sv5tk"},{"name":"hexo","_id":"ck2a5oy4u000j01zzejsoi8uz"}]}}